"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIAMPolicies = exports.migrate = exports.askAdditionalAuthQuestions = exports.updateWalkthrough = exports.serviceWalkthrough = exports.openConsole = void 0;
const syncAssets_1 = require("../sync-conflict-handler-assets/syncAssets");
const inquirer_1 = __importDefault(require("inquirer"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const open_1 = __importDefault(require("open"));
const aws_constants_1 = require("../aws-constants");
const graphql_transformer_core_1 = require("graphql-transformer-core");
const category_constants_1 = require("../../../category-constants");
const auth_config_to_app_sync_auth_type_bi_di_mapper_1 = require("../utils/auth-config-to-app-sync-auth-type-bi-di-mapper");
const resolver_config_to_conflict_resolution_bi_di_mapper_1 = require("../utils/resolver-config-to-conflict-resolution-bi-di-mapper");
const lodash_1 = __importDefault(require("lodash"));
const amplify_meta_utils_1 = require("../utils/amplify-meta-utils");
const amplify_cli_core_1 = require("amplify-cli-core");
const serviceName = 'AppSync';
const providerName = 'awscloudformation';
const graphqlSchemaDir = path_1.default.join(aws_constants_1.rootAssetDir, 'graphql-schemas');
const authProviderChoices = [
    {
        name: 'API key',
        value: 'API_KEY',
    },
    {
        name: 'Amazon Cognito User Pool',
        value: 'AMAZON_COGNITO_USER_POOLS',
    },
    {
        name: 'IAM',
        value: 'AWS_IAM',
    },
    {
        name: 'OpenID Connect',
        value: 'OPENID_CONNECT',
    },
];
exports.openConsole = context => {
    const amplifyMeta = context.amplify.getProjectMeta();
    const categoryAmplifyMeta = amplifyMeta[category_constants_1.category];
    let appSyncMeta;
    Object.keys(categoryAmplifyMeta).forEach(resourceName => {
        if (categoryAmplifyMeta[resourceName].service === serviceName && categoryAmplifyMeta[resourceName].output) {
            appSyncMeta = categoryAmplifyMeta[resourceName].output;
        }
    });
    if (appSyncMeta) {
        const { GraphQLAPIIdOutput } = appSyncMeta;
        const { Region } = amplifyMeta.providers[providerName];
        const consoleUrl = `https://console.aws.amazon.com/appsync/home?region=${Region}#/${GraphQLAPIIdOutput}/v1/queries`;
        open_1.default(consoleUrl, { wait: false });
    }
    else {
        context.print.error('AppSync API is not pushed in the cloud.');
    }
};
exports.serviceWalkthrough = async (context, defaultValuesFilename, serviceMetadata) => {
    const resourceName = resourceAlreadyExists(context);
    let authConfig;
    let defaultAuthType;
    let resolverConfig;
    if (resourceName) {
        const errMessage = 'You already have an AppSync API in your project. Use the "amplify update api" command to update your existing AppSync API.';
        context.print.warning(errMessage);
        context.usageData.emitError(new amplify_cli_core_1.ResourceAlreadyExistsError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const { amplify } = context;
    const { inputs } = serviceMetadata;
    const defaultValuesSrc = `${__dirname}/../default-values/${defaultValuesFilename}`;
    const { getAllDefaults } = require(defaultValuesSrc);
    const allDefaultValues = getAllDefaults(amplify.getProjectDetails());
    const resourceQuestions = [
        {
            type: inputs[1].type,
            name: inputs[1].key,
            message: inputs[1].question,
            validate: amplify.inputValidation(inputs[1]),
            default: () => {
                const defaultValue = allDefaultValues[inputs[1].key];
                return defaultValue;
            },
        },
    ];
    const resourceAnswers = await inquirer_1.default.prompt(resourceQuestions);
    resourceAnswers[inputs[0].key] = resourceAnswers[inputs[1].key];
    ({ authConfig, defaultAuthType } = await askDefaultAuthQuestion(context));
    ({ authConfig, resolverConfig } = await askAdditionalQuestions(context, authConfig, defaultAuthType));
    const schemaFileQuestion = {
        type: inputs[2].type,
        name: inputs[2].key,
        message: inputs[2].question,
        validate: amplify.inputValidation(inputs[2]),
        default: () => {
            const defaultValue = allDefaultValues[inputs[2].key];
            return defaultValue;
        },
    };
    const schemaFileAnswer = await inquirer_1.default.prompt(schemaFileQuestion);
    let schemaContent = '';
    let askToEdit = true;
    if (schemaFileAnswer[inputs[2].key]) {
        const filePathQuestion = {
            type: inputs[3].type,
            name: inputs[3].key,
            message: inputs[3].question,
            validate: amplify.inputValidation(inputs[3]),
        };
        const { schemaFilePath } = await inquirer_1.default.prompt(filePathQuestion);
        schemaContent = fs_extra_1.default.readFileSync(schemaFilePath, 'utf8');
        askToEdit = false;
    }
    else {
        const templateSelectionQuestion = {
            type: inputs[4].type,
            name: inputs[4].key,
            message: inputs[4].question,
            choices: inputs[4].options.filter(templateSchemaFilter(authConfig)),
            validate: amplify.inputValidation(inputs[4]),
        };
        const { templateSelection } = await inquirer_1.default.prompt(templateSelectionQuestion);
        const schemaFilePath = path_1.default.join(graphqlSchemaDir, templateSelection);
        schemaContent = fs_extra_1.default.readFileSync(schemaFilePath, 'utf8');
    }
    return {
        answers: resourceAnswers,
        output: {
            authConfig,
        },
        noCfnFile: true,
        resolverConfig,
        schemaContent,
        askToEdit,
    };
};
exports.updateWalkthrough = async (context) => {
    const { allResources } = await context.amplify.getResourceStatus();
    let resourceDir;
    let resourceName;
    let authConfig;
    let defaultAuthType;
    const resources = allResources.filter(resource => resource.service === 'AppSync');
    if (resources.length > 0) {
        const resource = resources[0];
        if (resource.providerPlugin !== providerName) {
            throw new Error(`The selected resource is not managed using AWS Cloudformation. Please use the AWS AppSync Console to make updates to your API - ${resource.resourceName}`);
        }
        ({ resourceName } = resource);
        const backEndDir = context.amplify.pathManager.getBackendDirPath();
        resourceDir = path_1.default.normalize(path_1.default.join(backEndDir, category_constants_1.category, resourceName));
    }
    else {
        const errMessage = 'No AppSync resource to update. Use the "amplify add api" command to update your existing AppSync API.';
        context.print.error(errMessage);
        context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const project = await graphql_transformer_core_1.readProjectConfiguration(resourceDir);
    let resolverConfig = project.config.ResolverConfig;
    const directiveMap = graphql_transformer_core_1.collectDirectivesByTypeNames(project.schema);
    let modelTypes = [];
    if (directiveMap.types) {
        Object.keys(directiveMap.types).forEach(type => {
            if (directiveMap.types[type].includes('model')) {
                modelTypes.push(type);
            }
        });
    }
    const updateChoices = [
        {
            name: 'Walkthrough all configurations',
            value: 'all',
        },
        {
            name: 'Update auth settings',
            value: 'authUpdate',
        },
    ];
    if (project.config && !lodash_1.default.isEmpty(project.config.ResolverConfig)) {
        updateChoices.push({ name: 'Disable DataStore for entire API', value: 'disableDatastore' });
    }
    else {
        updateChoices.push({ name: 'Enable DataStore for entire API', value: 'enableDatastore' });
    }
    const updateOptionQuestion = {
        type: 'list',
        name: 'updateOption',
        message: 'Select from the options below',
        choices: updateChoices,
    };
    const { updateOption } = await inquirer_1.default.prompt([updateOptionQuestion]);
    if (updateOption === 'enableDatastore') {
        resolverConfig = {
            project: { ConflictHandler: "AUTOMERGE", ConflictDetection: 'VERSION' },
        };
    }
    else if (updateOption === 'disableDatastore') {
        resolverConfig = {};
    }
    else if (updateOption === 'authUpdate') {
        ({ authConfig, defaultAuthType } = await askDefaultAuthQuestion(context));
        authConfig = await askAdditionalAuthQuestions(context, authConfig, defaultAuthType);
    }
    else if (updateOption === 'all') {
        ({ authConfig, defaultAuthType } = await askDefaultAuthQuestion(context));
        ({ authConfig, resolverConfig } = await askAdditionalQuestions(context, authConfig, defaultAuthType, modelTypes));
    }
    return {
        version: 1,
        serviceModification: {
            serviceName: 'AppSync',
            defaultAuthType: auth_config_to_app_sync_auth_type_bi_di_mapper_1.authConfigToAppSyncAuthType(authConfig ? authConfig.defaultAuthentication : undefined),
            additionalAuthTypes: authConfig && authConfig.additionalAuthenticationProviders
                ? authConfig.additionalAuthenticationProviders.map(auth_config_to_app_sync_auth_type_bi_di_mapper_1.authConfigToAppSyncAuthType)
                : undefined,
            conflictResolution: resolver_config_to_conflict_resolution_bi_di_mapper_1.resolverConfigToConflictResolution(resolverConfig),
        },
    };
};
async function askAdditionalQuestions(context, authConfig, defaultAuthType, modelTypes) {
    let resolverConfig;
    const advancedSettingsQuestion = {
        type: 'list',
        name: 'advancedSettings',
        message: 'Do you want to configure advanced settings for the GraphQL API',
        choices: [
            {
                name: 'No, I am done.',
                value: false,
            },
            {
                name: 'Yes, I want to make some additional changes.',
                value: true,
            },
        ],
    };
    const advancedSettingsAnswer = await inquirer_1.default.prompt([advancedSettingsQuestion]);
    if (advancedSettingsAnswer.advancedSettings) {
        authConfig = await askAdditionalAuthQuestions(context, authConfig, defaultAuthType);
        resolverConfig = await askResolverConflictQuestion(context, modelTypes);
    }
    return { authConfig, resolverConfig };
}
async function askResolverConflictQuestion(context, modelTypes) {
    let resolverConfig = {};
    if (await context.prompt.confirm('Configure conflict detection?')) {
        const askConflictResolutionStrategy = async (msg) => {
            let conflictResolutionStrategy;
            do {
                const conflictResolutionQuestion = {
                    type: 'list',
                    name: 'conflictResolutionStrategy',
                    message: msg,
                    default: 'AUTOMERGE',
                    choices: [
                        {
                            name: 'Auto Merge',
                            value: 'AUTOMERGE',
                        },
                        {
                            name: 'Optimistic Concurrency',
                            value: 'OPTIMISTIC_CONCURRENCY',
                        },
                        {
                            name: 'Custom Lambda',
                            value: 'LAMBDA',
                        },
                        {
                            name: 'Learn More',
                            value: 'Learn More',
                        },
                    ],
                };
                if (conflictResolutionStrategy === 'Learn More') {
                    conflictResolutionQuestion.prefix = syncAssets_1.dataStoreLearnMore;
                }
                ({ conflictResolutionStrategy } = await inquirer_1.default.prompt([conflictResolutionQuestion]));
            } while (conflictResolutionStrategy === 'Learn More');
            let syncConfig = {
                ConflictHandler: conflictResolutionStrategy,
                ConflictDetection: 'VERSION',
            };
            if (conflictResolutionStrategy === 'LAMBDA') {
                const { newFunction, lambdaFunctionName } = await askSyncFunctionQuestion(context);
                syncConfig.LambdaConflictHandler = {
                    name: lambdaFunctionName,
                    new: newFunction,
                };
            }
            return syncConfig;
        };
        resolverConfig.project = await askConflictResolutionStrategy('Select the default resolution strategy');
        if (modelTypes && modelTypes.length > 0) {
            if (await context.prompt.confirm('Do you want to override default per model settings?', false)) {
                const modelTypeQuestion = {
                    type: 'checkbox',
                    name: 'selectedModelTypes',
                    message: 'Select the models from below:',
                    choices: modelTypes,
                };
                const { selectedModelTypes } = await inquirer_1.default.prompt([modelTypeQuestion]);
                if (selectedModelTypes.length > 0) {
                    resolverConfig.models = {};
                    for (let i = 0; i < selectedModelTypes.length; i += 1) {
                        resolverConfig.models[selectedModelTypes[i]] = await askConflictResolutionStrategy(`Select the resolution strategy for ${selectedModelTypes[i]} model`);
                    }
                }
            }
        }
    }
    return resolverConfig;
}
async function askSyncFunctionQuestion(context) {
    const syncLambdaQuestion = {
        type: 'list',
        name: 'syncLambdaAnswer',
        message: 'Select from the options below',
        choices: [
            {
                name: 'Create a new Lambda Function',
                value: 'NEW',
            },
            {
                name: 'Existing Lambda Function',
                value: 'EXISTING',
            },
        ],
    };
    const { syncLambdaAnswer } = await inquirer_1.default.prompt([syncLambdaQuestion]);
    let lambdaFunctionName;
    const newFunction = syncLambdaAnswer === 'NEW';
    if (!newFunction) {
        const syncLambdaNameQuestion = {
            type: 'input',
            name: 'lambdaFunctionName',
            message: 'Enter lambda function name',
            validate: val => !!val,
        };
        ({ lambdaFunctionName } = await inquirer_1.default.prompt([syncLambdaNameQuestion]));
    }
    return { newFunction, lambdaFunctionName };
}
async function askDefaultAuthQuestion(context) {
    const currentAuthConfig = amplify_meta_utils_1.getAppSyncAuthConfig(context.amplify.getProjectMeta());
    const currentDefaultAuth = currentAuthConfig && currentAuthConfig.defaultAuthentication ? currentAuthConfig.defaultAuthentication.authenticationType : undefined;
    const defaultAuthTypeQuestion = {
        type: 'list',
        name: 'defaultAuthType',
        message: 'Choose the default authorization type for the API',
        choices: authProviderChoices,
        default: currentDefaultAuth,
    };
    const { defaultAuthType } = await inquirer_1.default.prompt([defaultAuthTypeQuestion]);
    const defaultAuth = await askAuthQuestions(defaultAuthType, context);
    return {
        authConfig: {
            defaultAuthentication: defaultAuth,
        },
        defaultAuthType,
    };
}
async function askAdditionalAuthQuestions(context, authConfig, defaultAuthType) {
    const currentAuthConfig = amplify_meta_utils_1.getAppSyncAuthConfig(context.amplify.getProjectMeta());
    authConfig.additionalAuthenticationProviders = [];
    if (await context.prompt.confirm('Configure additional auth types?')) {
        const remainingAuthProviderChoices = authProviderChoices.filter(p => p.value !== defaultAuthType);
        const currentAdditionalAuth = (currentAuthConfig && currentAuthConfig.additionalAuthenticationProviders
            ? currentAuthConfig.additionalAuthenticationProviders
            : []).map(authProvider => authProvider.authenticationType);
        const additionalProvidersQuestion = {
            type: 'checkbox',
            name: 'authType',
            message: 'Choose the additional authorization types you want to configure for the API',
            choices: remainingAuthProviderChoices,
            default: currentAdditionalAuth,
        };
        const additionalProvidersAnswer = await inquirer_1.default.prompt([additionalProvidersQuestion]);
        for (let i = 0; i < additionalProvidersAnswer.authType.length; i += 1) {
            const authProvider = additionalProvidersAnswer.authType[i];
            const config = await askAuthQuestions(authProvider, context, true);
            authConfig.additionalAuthenticationProviders.push(config);
        }
    }
    else {
        authConfig.additionalAuthenticationProviders = ((currentAuthConfig === null || currentAuthConfig === void 0 ? void 0 : currentAuthConfig.additionalAuthenticationProviders) || []).filter(p => p.authenticationType !== defaultAuthType);
    }
    return authConfig;
}
exports.askAdditionalAuthQuestions = askAdditionalAuthQuestions;
async function askAuthQuestions(authType, context, printLeadText = false) {
    if (authType === 'AMAZON_COGNITO_USER_POOLS') {
        if (printLeadText) {
            context.print.info('Cognito UserPool configuration');
        }
        const userPoolConfig = await askUserPoolQuestions(context);
        return userPoolConfig;
    }
    if (authType === 'API_KEY') {
        if (printLeadText) {
            context.print.info('API key configuration');
        }
        const apiKeyConfig = await askApiKeyQuestions();
        return apiKeyConfig;
    }
    if (authType === 'AWS_IAM') {
        return {
            authenticationType: 'AWS_IAM',
        };
    }
    if (authType === 'OPENID_CONNECT') {
        if (printLeadText) {
            context.print.info('OpenID Connect configuration');
        }
        const openIDConnectConfig = await askOpenIDConnectQuestions();
        return openIDConnectConfig;
    }
    const errMessage = `Unknown authType: ${authType}`;
    context.print.error(errMessage);
    context.usageData.emitError(new amplify_cli_core_1.UnknownResourceTypeError(errMessage));
    amplify_cli_core_1.exitOnNextTick(1);
}
async function askUserPoolQuestions(context) {
    let authResourceName = amplify_meta_utils_1.checkIfAuthExists(context);
    if (!authResourceName) {
        try {
            const { add } = require('amplify-category-auth');
            authResourceName = await add(context);
        }
        catch (e) {
            context.print.error('Auth plugin not installed in the CLI. You need to install it to use this feature.');
        }
    }
    else {
        context.print.info('Use a Cognito user pool configured as a part of this project.');
    }
    return {
        authenticationType: 'AMAZON_COGNITO_USER_POOLS',
        userPoolConfig: {
            userPoolId: `auth${authResourceName}`,
        },
    };
}
async function askApiKeyQuestions() {
    const apiKeyQuestions = [
        {
            type: 'input',
            name: 'description',
            message: 'Enter a description for the API key:',
        },
        {
            type: 'input',
            name: 'apiKeyExpirationDays',
            message: 'After how many days from now the API key should expire (1-365):',
            default: 7,
            validate: validateDays,
            filter: value => (isNaN(parseInt(value, 10)) ? value : parseInt(value, 10)),
        },
    ];
    const apiKeyConfig = await inquirer_1.default.prompt(apiKeyQuestions);
    return {
        authenticationType: 'API_KEY',
        apiKeyConfig,
    };
}
async function askOpenIDConnectQuestions() {
    const openIDConnectQuestions = [
        {
            type: 'input',
            name: 'name',
            message: 'Enter a name for the OpenID Connect provider:',
        },
        {
            type: 'input',
            name: 'issuerUrl',
            message: 'Enter the OpenID Connect provider domain (Issuer URL):',
            validate: validateIssuerUrl,
        },
        {
            type: 'input',
            name: 'clientId',
            message: 'Enter the Client Id from your OpenID Client Connect application (optional):',
        },
        {
            type: 'input',
            name: 'iatTTL',
            message: 'Enter the number of milliseconds a token is valid after being issued to a user:',
            validate: validateTTL,
        },
        {
            type: 'input',
            name: 'authTTL',
            message: 'Enter the number of milliseconds a token is valid after being authenticated:',
            validate: validateTTL,
        },
    ];
    const openIDConnectConfig = await inquirer_1.default.prompt(openIDConnectQuestions);
    return {
        authenticationType: 'OPENID_CONNECT',
        openIDConnectConfig,
    };
}
function validateDays(input) {
    const isValid = /^\d+$/.test(input);
    const days = isValid ? parseInt(input, 10) : 0;
    if (!isValid || days < 1 || days > 365) {
        return 'Number of days must be between 1 and 365.';
    }
    return true;
}
function validateIssuerUrl(input) {
    const isValid = /^(((?!http:\/\/(?!localhost))([a-zA-Z0-9.]{1,}):\/\/([a-zA-Z0-9-._~:?#@!$&'()*+,;=/]{1,})\/)|(?!http)(?!https)([a-zA-Z0-9.]{1,}):\/\/)$/.test(input);
    if (!isValid) {
        return 'The value must be a valid URI with a trailing forward slash. HTTPS must be used instead of HTTP unless you are using localhost.';
    }
    return true;
}
function validateTTL(input) {
    const isValid = /^\d+$/.test(input);
    if (!isValid) {
        return 'The value must be a number.';
    }
    return true;
}
function resourceAlreadyExists(context) {
    const { amplify } = context;
    const { amplifyMeta } = amplify.getProjectDetails();
    let resourceName;
    if (amplifyMeta[category_constants_1.category]) {
        const categoryResources = amplifyMeta[category_constants_1.category];
        Object.keys(categoryResources).forEach(resource => {
            if (categoryResources[resource].service === serviceName) {
                resourceName = resource;
            }
        });
    }
    return resourceName;
}
exports.migrate = async (context) => {
    await context.amplify.executeProviderUtils(context, 'awscloudformation', 'compileSchema', {
        forceCompile: true,
        migrate: true,
    });
};
exports.getIAMPolicies = (resourceName, crudOptions, context) => {
    let policy = {};
    const actions = [];
    crudOptions.forEach(crudOption => {
        switch (crudOption) {
            case 'create':
                actions.push('appsync:Create*', 'appsync:StartSchemaCreation', 'appsync:GraphQL');
                break;
            case 'update':
                actions.push('appsync:Update*');
                break;
            case 'read':
                actions.push('appsync:Get*', 'appsync:List*');
                break;
            case 'delete':
                actions.push('appsync:Delete*');
                break;
            default:
                console.log(`${crudOption} not supported`);
        }
    });
    policy = {
        Effect: 'Allow',
        Action: actions,
        Resource: [
            {
                'Fn::Join': [
                    '',
                    [
                        'arn:aws:appsync:',
                        { Ref: 'AWS::Region' },
                        ':',
                        { Ref: 'AWS::AccountId' },
                        ':apis/',
                        {
                            Ref: `${category_constants_1.category}${resourceName}GraphQLAPIIdOutput`,
                        },
                        '/*',
                    ],
                ],
            },
        ],
    };
    const attributes = ['GraphQLAPIIdOutput', 'GraphQLAPIEndpointOutput'];
    if (amplify_meta_utils_1.authConfigHasApiKey(amplify_meta_utils_1.getAppSyncAuthConfig(context.amplify.getProjectMeta()))) {
        attributes.push('GraphQLAPIKeyOutput');
    }
    return { policy, attributes };
};
const templateSchemaFilter = authConfig => {
    const authIncludesCognito = getAuthTypes(authConfig).includes('AMAZON_COGNITO_USER_POOLS');
    return (templateOption) => authIncludesCognito || templateOption.value !== 'single-object-auth-schema.graphql';
};
const getAuthTypes = authConfig => {
    const additionalAuthTypes = (authConfig.additionalAuthenticationProviders || [])
        .map(provider => provider.authenticationType)
        .filter(t => !!t);
    const uniqueAuthTypes = new Set([...additionalAuthTypes, authConfig.defaultAuthentication.authenticationType]);
    return [...uniqueAuthTypes.keys()];
};
//# sourceMappingURL=appSync-walkthrough.js.map