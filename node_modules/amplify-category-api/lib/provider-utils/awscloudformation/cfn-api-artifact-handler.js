"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeResolverConfig = exports.getCfnApiArtifactHandler = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const category_constants_1 = require("../../category-constants");
const aws_constants_1 = require("./aws-constants");
const graphql_transformer_core_1 = require("graphql-transformer-core");
const resolver_config_to_conflict_resolution_bi_di_mapper_1 = require("./utils/resolver-config-to-conflict-resolution-bi-di-mapper");
const auth_config_to_app_sync_auth_type_bi_di_mapper_1 = require("./utils/auth-config-to-app-sync-auth-type-bi-di-mapper");
const uuid_1 = __importDefault(require("uuid"));
const lodash_1 = __importDefault(require("lodash"));
const amplify_meta_utils_1 = require("./utils/amplify-meta-utils");
const print_api_key_warnings_1 = require("./utils/print-api-key-warnings");
exports.getCfnApiArtifactHandler = (context) => {
    return new CfnApiArtifactHandler(context);
};
const resolversDirName = 'resolvers';
const stacksDirName = 'stacks';
const defaultStackName = 'CustomResources.json';
const defaultCfnParameters = (apiName) => ({
    AppSyncApiName: apiName,
    DynamoDBBillingMode: 'PAY_PER_REQUEST',
    DynamoDBEnableServerSideEncryption: false,
});
class CfnApiArtifactHandler {
    constructor(context) {
        this.createArtifacts = async (request) => {
            const existingApiName = amplify_meta_utils_1.getAppSyncResourceName(this.context.amplify.getProjectMeta());
            if (existingApiName) {
                throw new Error(`GraphQL API ${existingApiName} already exists in the project. Use 'amplify update api' to make modifications.`);
            }
            const serviceConfig = request.serviceConfiguration;
            const resourceDir = this.getResourceDir(serviceConfig.apiName);
            fs_extra_1.default.ensureDirSync(resourceDir);
            const resolverDirectoryPath = path_1.default.join(resourceDir, resolversDirName);
            if (!fs_extra_1.default.existsSync(resolverDirectoryPath)) {
                fs_extra_1.default.mkdirSync(resolverDirectoryPath);
            }
            const stacksDirectoryPath = path_1.default.join(resourceDir, stacksDirName);
            if (!fs_extra_1.default.existsSync(stacksDirectoryPath)) {
                fs_extra_1.default.mkdirSync(stacksDirectoryPath);
            }
            await this.updateTransformerConfigVersion(resourceDir);
            serviceConfig.conflictResolution = await this.createResolverResources(serviceConfig.conflictResolution);
            await exports.writeResolverConfig(serviceConfig.conflictResolution, resourceDir);
            fs_extra_1.default.copyFileSync(path_1.default.join(aws_constants_1.rootAssetDir, 'cloudformation-templates', 'defaultCustomResources.json'), path_1.default.join(resourceDir, stacksDirName, defaultStackName));
            this.writeSchema(resourceDir, serviceConfig.transformSchema);
            const authConfig = this.extractAuthConfig(serviceConfig);
            await this.context.amplify.executeProviderUtils(this.context, 'awscloudformation', 'compileSchema', {
                resourceDir,
                parameters: this.getCfnParameters(serviceConfig.apiName, authConfig, resourceDir),
                authConfig,
            });
            this.context.amplify.updateamplifyMetaAfterResourceAdd(category_constants_1.category, serviceConfig.apiName, this.createAmplifyMeta(authConfig));
            return serviceConfig.apiName;
        };
        this.updateArtifacts = async (request) => {
            const updates = request.serviceModification;
            const apiName = amplify_meta_utils_1.getAppSyncResourceName(this.context.amplify.getProjectMeta());
            if (!apiName) {
                throw new Error(`No AppSync API configured in the project. Use 'amplify add api' to create an API.`);
            }
            const resourceDir = this.getResourceDir(apiName);
            if (updates.transformSchema) {
                this.writeSchema(resourceDir, updates.transformSchema);
            }
            if (updates.conflictResolution) {
                updates.conflictResolution = await this.createResolverResources(updates.conflictResolution);
                await exports.writeResolverConfig(updates.conflictResolution, resourceDir);
            }
            const authConfig = amplify_meta_utils_1.getAppSyncAuthConfig(this.context.amplify.getProjectMeta());
            const oldConfigHadApiKey = amplify_meta_utils_1.authConfigHasApiKey(authConfig);
            if (updates.defaultAuthType) {
                authConfig.defaultAuthentication = auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig(updates.defaultAuthType);
            }
            if (updates.additionalAuthTypes) {
                authConfig.additionalAuthenticationProviders = updates.additionalAuthTypes.map(auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig);
            }
            await this.context.amplify.executeProviderUtils(this.context, 'awscloudformation', 'compileSchema', {
                resourceDir,
                parameters: this.getCfnParameters(apiName, authConfig, resourceDir),
                authConfig,
            });
            this.context.amplify.updateamplifyMetaAfterResourceUpdate(category_constants_1.category, apiName, 'output', { authConfig });
            this.context.amplify.updateBackendConfigAfterResourceUpdate(category_constants_1.category, apiName, 'output', { authConfig });
            print_api_key_warnings_1.printApiKeyWarnings(this.context, oldConfigHadApiKey, amplify_meta_utils_1.authConfigHasApiKey(authConfig));
        };
        this.writeSchema = (resourceDir, schema) => {
            fs_extra_1.default.writeFileSync(path_1.default.join(resourceDir, aws_constants_1.gqlSchemaFilename), schema);
        };
        this.getResourceDir = (apiName) => path_1.default.join(this.context.amplify.pathManager.getBackendDirPath(), category_constants_1.category, apiName);
        this.createAmplifyMeta = authConfig => ({
            service: 'AppSync',
            providerPlugin: aws_constants_1.provider,
            output: {
                authConfig,
            },
        });
        this.extractAuthConfig = (config) => ({
            defaultAuthentication: auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig(config.defaultAuthType),
            additionalAuthenticationProviders: (config.additionalAuthTypes || []).map(auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig),
        });
        this.updateTransformerConfigVersion = async (resourceDir) => {
            const localTransformerConfig = await graphql_transformer_core_1.readTransformerConfiguration(resourceDir);
            localTransformerConfig.Version = graphql_transformer_core_1.TRANSFORM_CURRENT_VERSION;
            localTransformerConfig.ElasticsearchWarning = true;
            await graphql_transformer_core_1.writeTransformerConfiguration(resourceDir, localTransformerConfig);
        };
        this.createResolverResources = async (conflictResolution = {}) => {
            const newConflictResolution = lodash_1.default.cloneDeep(conflictResolution);
            const generateLambdaIfNew = async (strat) => {
                if (strat && strat.type === 'LAMBDA' && strat.resolver.type === 'NEW') {
                    strat.resolver = {
                        type: 'EXISTING',
                        name: await this.createSyncFunction(),
                    };
                }
            };
            await generateLambdaIfNew(newConflictResolution.defaultResolutionStrategy);
            await Promise.all((newConflictResolution.perModelResolutionStrategy || [])
                .map(perModelStrat => perModelStrat.resolutionStrategy)
                .map(generateLambdaIfNew));
            return newConflictResolution;
        };
        this.getCfnParameters = (apiName, authConfig, resourceDir) => {
            const params = this.context.amplify.readJsonFile(path_1.default.join(resourceDir, aws_constants_1.cfnParametersFilename), undefined, false) || defaultCfnParameters(apiName);
            const cognitoPool = this.getCognitoUserPool(authConfig);
            if (cognitoPool) {
                params.AuthCognitoUserPoolId = cognitoPool;
            }
            else {
                delete params.AuthCognitoUserPoolId;
            }
            return params;
        };
        this.getCognitoUserPool = authConfig => {
            const additionalUserPoolProvider = (authConfig.additionalAuthenticationProviders || []).find(provider => provider.authenticationType === 'AMAZON_COGNITO_USER_POOLS');
            const defaultAuth = authConfig.defaultAuthentication || {};
            if (defaultAuth.authenticationType === 'AMAZON_COGNITO_USER_POOLS' || additionalUserPoolProvider) {
                let userPoolId;
                const configuredUserPoolName = amplify_meta_utils_1.checkIfAuthExists(this.context);
                if (authConfig.userPoolConfig) {
                    ({ userPoolId } = authConfig.userPoolConfig);
                }
                else if (additionalUserPoolProvider && additionalUserPoolProvider.userPoolConfig) {
                    ({ userPoolId } = additionalUserPoolProvider.userPoolConfig);
                }
                else if (configuredUserPoolName) {
                    userPoolId = `auth${configuredUserPoolName}`;
                }
                else {
                    throw new Error('Cannot find a configured Cognito User Pool.');
                }
                return {
                    'Fn::GetAtt': [userPoolId, 'Outputs.UserPoolId'],
                };
            }
        };
        this.createSyncFunction = async () => {
            const targetDir = this.context.amplify.pathManager.getBackendDirPath();
            const assetDir = path_1.default.normalize(path_1.default.join(aws_constants_1.rootAssetDir, 'sync-conflict-handler'));
            const [shortId] = uuid_1.default().split('-');
            const functionName = `syncConflictHandler${shortId}`;
            const functionProps = {
                functionName: `${functionName}`,
                roleName: `${functionName}LambdaRole`,
            };
            const copyJobs = [
                {
                    dir: assetDir,
                    template: 'sync-conflict-handler-index.js.ejs',
                    target: `${targetDir}/function/${functionName}/src/index.js`,
                },
                {
                    dir: assetDir,
                    template: 'sync-conflict-handler-package.json.ejs',
                    target: `${targetDir}/function/${functionName}/src/package.json`,
                },
                {
                    dir: assetDir,
                    template: 'sync-conflict-handler-template.json.ejs',
                    target: `${targetDir}/function/${functionName}/${functionName}-cloudformation-template.json`,
                },
            ];
            await this.context.amplify.copyBatch(this.context, copyJobs, functionProps, true);
            const backendConfigs = {
                service: "Lambda",
                providerPlugin: aws_constants_1.provider,
                build: true,
            };
            await this.context.amplify.updateamplifyMetaAfterResourceAdd('function', functionName, backendConfigs);
            this.context.print.success(`Successfully added ${functionName} function locally`);
            return functionName + '-${env}';
        };
        this.context = context;
    }
}
exports.writeResolverConfig = async (conflictResolution, resourceDir) => {
    const localTransformerConfig = await graphql_transformer_core_1.readTransformerConfiguration(resourceDir);
    localTransformerConfig.ResolverConfig = resolver_config_to_conflict_resolution_bi_di_mapper_1.conflictResolutionToResolverConfig(conflictResolution);
    await graphql_transformer_core_1.writeTransformerConfiguration(resourceDir, localTransformerConfig);
};
//# sourceMappingURL=cfn-api-artifact-handler.js.map