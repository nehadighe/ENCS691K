"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleAmplifyEvent = exports.executeAmplifyHeadlessCommand = exports.executeAmplifyCommand = exports.getPermissionPolicies = exports.initEnv = exports.migrate = exports.console = void 0;
const console_1 = require("./commands/api/console");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const cfn_api_artifact_handler_1 = require("./provider-utils/awscloudformation/cfn-api-artifact-handler");
const amplify_util_headless_input_1 = require("amplify-util-headless-input");
const category = 'api';
const categories = 'categories';
async function console(context) {
    await console_1.run(context);
}
exports.console = console;
async function migrate(context, serviceName) {
    const { projectPath, amplifyMeta } = context.migrationInfo;
    const migrateResourcePromises = [];
    Object.keys(amplifyMeta).forEach(categoryName => {
        if (categoryName === category) {
            Object.keys(amplifyMeta[category]).forEach(resourceName => {
                try {
                    if (amplifyMeta[category][resourceName].providerPlugin) {
                        const providerController = require(`./provider-utils/${amplifyMeta[category][resourceName].providerPlugin}/index`);
                        if (providerController) {
                            if (!serviceName || serviceName === amplifyMeta[category][resourceName].service) {
                                migrateResourcePromises.push(providerController.migrateResource(context, projectPath, amplifyMeta[category][resourceName].service, resourceName));
                            }
                        }
                    }
                    else {
                        context.print.error(`Provider not configured for ${category}: ${resourceName}`);
                    }
                }
                catch (e) {
                    context.print.warning(`Could not run migration for ${category}: ${resourceName}`);
                    throw e;
                }
            });
        }
    });
    await Promise.all(migrateResourcePromises);
}
exports.migrate = migrate;
async function initEnv(context) {
    const datasource = 'Aurora Serverless';
    const service = 'service';
    const rdsInit = 'rdsInit';
    const rdsRegion = 'rdsRegion';
    const rdsClusterIdentifier = 'rdsClusterIdentifier';
    const rdsSecretStoreArn = 'rdsSecretStoreArn';
    const rdsDatabaseName = 'rdsDatabaseName';
    const { amplify } = context;
    const backendConfigFilePath = amplify.pathManager.getBackendConfigFilePath();
    if (!fs_extra_1.default.existsSync(backendConfigFilePath)) {
        return;
    }
    const backendConfig = amplify.readJsonFile(backendConfigFilePath);
    if (!backendConfig[category]) {
        return;
    }
    let resourceName;
    const apis = Object.keys(backendConfig[category]);
    for (let i = 0; i < apis.length; i += 1) {
        if (backendConfig[category][apis[i]][service] === 'AppSync') {
            resourceName = apis[i];
            break;
        }
    }
    if (!resourceName) {
        return;
    }
    if (!backendConfig[category][resourceName][rdsInit]) {
        return;
    }
    const providerController = require('./provider-utils/awscloudformation/index');
    if (!providerController) {
        context.print.error('Provider not configured for this category');
        return;
    }
    const currEnv = amplify.getEnvInfo().envName;
    const teamProviderInfoFilePath = amplify.pathManager.getProviderInfoFilePath();
    const teamProviderInfo = amplify.readJsonFile(teamProviderInfoFilePath);
    if (teamProviderInfo[currEnv][categories] &&
        teamProviderInfo[currEnv][categories][category] &&
        teamProviderInfo[currEnv][categories][category][resourceName] &&
        teamProviderInfo[currEnv][categories][category][resourceName] &&
        teamProviderInfo[currEnv][categories][category][resourceName][rdsRegion]) {
        return;
    }
    return providerController
        .addDatasource(context, category, datasource)
        .then(answers => {
        if (!teamProviderInfo[currEnv][categories]) {
            teamProviderInfo[currEnv][categories] = {};
        }
        if (!teamProviderInfo[currEnv][categories][category]) {
            teamProviderInfo[currEnv][categories][category] = {};
        }
        if (!teamProviderInfo[currEnv][categories][category][resourceName]) {
            teamProviderInfo[currEnv][categories][category][resourceName] = {};
        }
        teamProviderInfo[currEnv][categories][category][resourceName][rdsRegion] = answers.region;
        teamProviderInfo[currEnv][categories][category][resourceName][rdsClusterIdentifier] = answers.dbClusterArn;
        teamProviderInfo[currEnv][categories][category][resourceName][rdsSecretStoreArn] = answers.secretStoreArn;
        teamProviderInfo[currEnv][categories][category][resourceName][rdsDatabaseName] = answers.databaseName;
        fs_extra_1.default.writeFileSync(teamProviderInfoFilePath, JSON.stringify(teamProviderInfo, null, 4));
    })
        .then(() => {
        context.amplify.executeProviderUtils(context, 'awscloudformation', 'compileSchema', { forceCompile: true });
    });
}
exports.initEnv = initEnv;
async function getPermissionPolicies(context, resourceOpsMapping) {
    const amplifyMetaFilePath = context.amplify.pathManager.getAmplifyMetaFilePath();
    const amplifyMeta = context.amplify.readJsonFile(amplifyMetaFilePath);
    const permissionPolicies = [];
    const resourceAttributes = [];
    await Promise.all(Object.keys(resourceOpsMapping).map(async (resourceName) => {
        try {
            const providerName = amplifyMeta[category][resourceName].providerPlugin;
            if (providerName) {
                const providerController = require(`./provider-utils/${providerName}/index`);
                const { policy, attributes } = await providerController.getPermissionPolicies(context, amplifyMeta[category][resourceName].service, resourceName, resourceOpsMapping[resourceName]);
                permissionPolicies.push(policy);
                resourceAttributes.push({ resourceName, attributes, category });
            }
            else {
                context.print.error(`Provider not configured for ${category}: ${resourceName}`);
            }
        }
        catch (e) {
            context.print.warning(`Could not get policies for ${category}: ${resourceName}`);
            throw e;
        }
    }));
    return { permissionPolicies, resourceAttributes };
}
exports.getPermissionPolicies = getPermissionPolicies;
async function executeAmplifyCommand(context) {
    let commandPath = path_1.default.normalize(path_1.default.join(__dirname, 'commands'));
    if (context.input.command === 'help') {
        commandPath = path_1.default.join(commandPath, category);
    }
    else {
        commandPath = path_1.default.join(commandPath, category, context.input.command);
    }
    const commandModule = require(commandPath);
    await commandModule.run(context);
}
exports.executeAmplifyCommand = executeAmplifyCommand;
exports.executeAmplifyHeadlessCommand = async (context, headlessPayload) => {
    switch (context.input.command) {
        case 'add':
            await cfn_api_artifact_handler_1.getCfnApiArtifactHandler(context).createArtifacts(await amplify_util_headless_input_1.validateAddApiRequest(headlessPayload));
            break;
        case 'update':
            await cfn_api_artifact_handler_1.getCfnApiArtifactHandler(context).updateArtifacts(await amplify_util_headless_input_1.validateUpdateApiRequest(headlessPayload));
            break;
        default:
            context.print.error(`Headless mode for ${context.input.command} api is not implemented yet`);
    }
};
async function handleAmplifyEvent(context, args) {
    context.print.info(`${category} handleAmplifyEvent to be implemented`);
    context.print.info(`Received event args ${args}`);
}
exports.handleAmplifyEvent = handleAmplifyEvent;
//# sourceMappingURL=index.js.map