"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeConstrainedInvoker = exports.start = void 0;
const amplify_category_function_1 = require("amplify-category-function");
const path = require("path");
const inquirer = require("inquirer");
const loadMinimal_1 = require("../utils/lambda/loadMinimal");
const utils_1 = require("../utils");
const DEFAULT_TIMEOUT_SECONDS = 10;
function start(context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!context.input.subCommands || context.input.subCommands.length < 1) {
            throw new Error('Specify the function name to invoke with "amplify mock function <function name>"');
        }
        const resourceName = context.input.subCommands[0];
        // check that the resource is mockable
        const mockable = amplify_category_function_1.isMockable(context, resourceName);
        if (!mockable.isMockable) {
            throw new Error(`Unable to mock ${resourceName}. ${mockable.reason}`);
        }
        const { amplify } = context;
        const resourcePath = path.join(amplify.pathManager.getBackendDirPath(), amplify_category_function_1.category, resourceName);
        const eventNameValidator = amplify.inputValidation({
            operator: 'regex',
            value: '^[a-zA-Z0-9/._-]+?\\.json$',
            onErrorMsg: 'Provide a valid unix-like path to a .json file',
            required: true,
        });
        let eventName = context.input.options ? context.input.options.event : undefined;
        let promptForEvent = true;
        if (eventName) {
            const validatorOutput = eventNameValidator(eventName);
            const isValid = typeof validatorOutput !== 'string';
            if (!isValid) {
                context.print.warning(validatorOutput);
            }
            else {
                promptForEvent = false;
            }
        }
        if (promptForEvent) {
            const resourceQuestions = [
                {
                    type: 'input',
                    name: 'eventName',
                    message: `Provide the path to the event JSON object relative to ${resourcePath}`,
                    validate: eventNameValidator,
                    default: 'src/event.json',
                },
            ];
            const resourceAnswers = yield inquirer.prompt(resourceQuestions);
            eventName = resourceAnswers.eventName;
        }
        const event = amplify.readJsonFile(path.resolve(path.join(resourcePath, eventName)));
        const lambdaConfig = loadMinimal_1.loadMinimalLambdaConfig(context, resourceName, { env: context.amplify.getEnvInfo().envName });
        if (!lambdaConfig || !lambdaConfig.handler) {
            throw new Error(`Could not parse handler for ${resourceName} from cloudformation file`);
        }
        const { allResources } = yield context.amplify.getResourceStatus();
        const envVars = utils_1.hydrateAllEnvVars(allResources, lambdaConfig.environment);
        const invoker = yield amplify_category_function_1.getInvoker(context, { resourceName, handler: lambdaConfig.handler, envVars });
        context.print.success('Starting execution...');
        yield exports.timeConstrainedInvoker(invoker({ event }), context.input.options)
            .then(result => {
            const msg = typeof result === 'object' ? JSON.stringify(result) : result;
            context.print.success('Result:');
            context.print.info(typeof result === 'undefined' ? '' : msg);
        })
            .catch(error => {
            context.print.error(`${resourceName} failed with the following error:`);
            context.print.info(error);
        })
            .then(() => context.print.success('Finished execution.'));
    });
}
exports.start = start;
exports.timeConstrainedInvoker = (promise, options) => Promise.race([promise, getTimer(options)]);
const getTimer = (options) => {
    const inputTimeout = Number.parseInt(options === null || options === void 0 ? void 0 : options.timeout, 10);
    const lambdaTimeoutSeconds = !!inputTimeout && inputTimeout > 0 ? inputTimeout : DEFAULT_TIMEOUT_SECONDS;
    const timeoutErrorMessage = `Lambda execution timed out after ${lambdaTimeoutSeconds} seconds. Press ctrl + C to exit the process.
    To increase the lambda timeout use the --timeout parameter to set a value in seconds.
    Note that the maximum Lambda execution time is 15 minutes:
    https://aws.amazon.com/about-aws/whats-new/2018/10/aws-lambda-supports-functions-that-can-run-up-to-15-minutes/\n`;
    return new Promise((_, reject) => setTimeout(() => reject(new Error(timeoutErrorMessage)), lambdaTimeoutSeconds * 1000));
};
//# sourceMappingURL=index.js.map