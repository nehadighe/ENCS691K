"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
async function run(context, category, resourceName) {
    const { allResources } = await context.amplify.getResourceStatus(category, resourceName);
    const resources = allResources.filter(resource => resource.service === "Lambda").filter(resource => resource.build);
    const buildPromises = [];
    for (let i = 0; i < resources.length; i += 1) {
        buildPromises.push(buildResource(context, resources[i]));
    }
    return Promise.all(buildPromises);
}
async function buildResource(context, resource) {
    const resourcePath = path_1.default.join(context.amplify.pathManager.getBackendDirPath(), resource.category, resource.resourceName);
    let breadcrumbs = context.amplify.readBreadcrumbs(context, resource.category, resource.resourceName);
    let zipFilename = resource.distZipFilename;
    const runtimePlugin = await context.amplify.loadRuntimePlugin(context, breadcrumbs.pluginId);
    const depCheck = await runtimePlugin.checkDependencies();
    if (!depCheck.hasRequiredDependencies) {
        context.print.error(depCheck.errorMessage || `You are missing dependencies required to package ${resource.resourceName}`);
        throw new Error(`Missing required dependencies to package ${resource.resourceName}`);
    }
    let rebuilt = false;
    if (breadcrumbs.scripts && breadcrumbs.scripts.build) {
        throw new Error('Executing custom build scripts is not yet implemented');
    }
    else {
        const buildRequest = {
            env: context.amplify.getEnvInfo().envName,
            srcRoot: resourcePath,
            runtime: breadcrumbs.functionRuntime,
            legacyBuildHookParams: {
                projectRoot: context.amplify.pathManager.searchProjectRootPath(),
                resourceName: resource.resourceName,
            },
            lastBuildTimestamp: resource.lastBuildTimeStamp ? new Date(resource.lastBuildTimeStamp) : undefined,
        };
        rebuilt = (await runtimePlugin.build(buildRequest)).rebuilt;
    }
    context.amplify.updateamplifyMetaAfterBuild(resource);
    const distDir = path_1.default.join(resourcePath, 'dist');
    if (!fs_extra_1.default.existsSync(distDir)) {
        fs_extra_1.default.mkdirSync(distDir);
    }
    const destination = path_1.default.join(distDir, 'latest-build.zip');
    let packagePromise;
    if (breadcrumbs.scripts && breadcrumbs.scripts.package) {
        throw new Error('Executing custom package scripts is not yet implemented');
    }
    else {
        const packageRequest = {
            env: context.amplify.getEnvInfo().envName,
            srcRoot: resourcePath,
            dstFilename: destination,
            runtime: breadcrumbs.functionRuntime,
            lastPackageTimestamp: resource.lastPackageTimestamp ? new Date(resource.lastPackageTimestamp) : undefined,
            lastBuildTimestamp: rebuilt ? new Date() : new Date(resource.lastBuildTimeStamp),
        };
        packagePromise = runtimePlugin.package(packageRequest);
    }
    return new Promise((resolve, reject) => {
        packagePromise
            .then(result => {
            const packageHash = result.packageHash;
            zipFilename = packageHash ? `${resource.resourceName}-${packageHash}-build.zip` : zipFilename;
            context.amplify.updateAmplifyMetaAfterPackage(resource, zipFilename);
            resolve({ zipFilename, zipFilePath: destination });
        })
            .catch(err => reject(new Error(`Package command failed with error [${err}]`)));
    });
}
module.exports = {
    run,
    buildResource,
};
//# sourceMappingURL=build-resources.js.map