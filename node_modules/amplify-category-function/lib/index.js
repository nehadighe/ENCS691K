"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleAmplifyEvent = exports.executeAmplifyCommand = exports.isMockable = exports.getInvoker = exports.initEnv = exports.getPermissionPolicies = exports.migrate = exports.console = exports.update = exports.add = void 0;
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
var constants_2 = require("./constants");
Object.defineProperty(exports, "category", { enumerable: true, get: function () { return constants_2.category; } });
const amplify_cli_core_1 = require("amplify-cli-core");
const promise_sequential_1 = __importDefault(require("promise-sequential"));
const awscloudformation_1 = require("./provider-utils/awscloudformation");
const supported_services_1 = require("./provider-utils/supported-services");
const lodash_1 = __importDefault(require("lodash"));
var packageLayer_1 = require("./provider-utils/awscloudformation/utils/packageLayer");
Object.defineProperty(exports, "packageLayer", { enumerable: true, get: function () { return packageLayer_1.packageLayer; } });
Object.defineProperty(exports, "hashLayerResource", { enumerable: true, get: function () { return packageLayer_1.hashLayerResource; } });
var constants_3 = require("./provider-utils/awscloudformation/utils/constants");
Object.defineProperty(exports, "ServiceName", { enumerable: true, get: function () { return constants_3.ServiceName; } });
const layerParams_1 = require("./provider-utils/awscloudformation/utils/layerParams");
var layerParams_2 = require("./provider-utils/awscloudformation/utils/layerParams");
Object.defineProperty(exports, "isMultiEnvLayer", { enumerable: true, get: function () { return layerParams_2.isMultiEnvLayer; } });
async function add(context, providerName, service, parameters) {
    const options = {
        service,
        providerPlugin: providerName,
        build: true,
    };
    const providerController = require(`./provider-utils/${providerName}/index`);
    if (!providerController) {
        context.print.error('Provider not configured for this category');
        return;
    }
    return providerController.addResource(context, constants_1.category, service, options, parameters);
}
exports.add = add;
async function update(context, providerName, service, parameters, resourceToUpdate) {
    const providerController = require(`./provider-utils/${providerName}/index`);
    if (!providerController) {
        context.print.error('Provider not configured for this category');
        return;
    }
    return providerController.updateResource(context, constants_1.category, service, parameters, resourceToUpdate);
}
exports.update = update;
async function console(context) {
    context.print.info(`to be implemented: ${constants_1.category} console`);
}
exports.console = console;
async function migrate(context) {
    const { projectPath, amplifyMeta } = context.migrationInfo;
    const migrateResourcePromises = [];
    Object.keys(amplifyMeta).forEach(categoryName => {
        if (categoryName === constants_1.category) {
            Object.keys(amplifyMeta[constants_1.category]).forEach(resourceName => {
                try {
                    const providerController = require(`./provider-utils/${amplifyMeta[constants_1.category][resourceName].providerPlugin}/index`);
                    if (providerController) {
                        migrateResourcePromises.push(providerController.migrateResource(context, projectPath, amplifyMeta[constants_1.category][resourceName].service, resourceName));
                    }
                    else {
                        context.print.error(`Provider not configured for ${constants_1.category}: ${resourceName}`);
                    }
                }
                catch (e) {
                    context.print.warning(`Could not run migration for ${constants_1.category}: ${resourceName}`);
                    throw e;
                }
            });
        }
    });
    await Promise.all(migrateResourcePromises);
}
exports.migrate = migrate;
async function getPermissionPolicies(context, resourceOpsMapping) {
    const amplifyMeta = context.amplify.getProjectMeta();
    const permissionPolicies = [];
    const resourceAttributes = [];
    Object.keys(resourceOpsMapping).forEach(resourceName => {
        try {
            const providerName = amplifyMeta[constants_1.category][resourceName].providerPlugin;
            if (providerName) {
                const providerController = require(`./provider-utils/${providerName}/index`);
                const { policy, attributes } = providerController.getPermissionPolicies(context, amplifyMeta[constants_1.category][resourceName].service, resourceName, resourceOpsMapping[resourceName]);
                permissionPolicies.push(policy);
                resourceAttributes.push({ resourceName, attributes, category: constants_1.category });
            }
            else {
                context.print.error(`Provider not configured for ${constants_1.category}: ${resourceName}`);
            }
        }
        catch (e) {
            context.print.warning(`Could not get policies for ${constants_1.category}: ${resourceName}`);
            throw e;
        }
    });
    return { permissionPolicies, resourceAttributes };
}
exports.getPermissionPolicies = getPermissionPolicies;
async function initEnv(context) {
    const { amplify } = context;
    const { envName } = amplify.getEnvInfo();
    const { allResources, resourcesToBeCreated, resourcesToBeDeleted, resourcesToBeUpdated } = await amplify.getResourceStatus(constants_1.category);
    const resourceCategoryFilter = resource => resource.category === constants_1.category;
    resourcesToBeDeleted.filter(resourceCategoryFilter).forEach(functionResource => {
        amplify.removeResourceParameters(context, constants_1.category, functionResource.resourceName);
    });
    const tasks = resourcesToBeCreated.concat(resourcesToBeUpdated).filter(resourceCategoryFilter);
    const functionTasks = tasks.map(functionResource => {
        const { resourceName, service } = functionResource;
        return async () => {
            const config = await awscloudformation_1.updateConfigOnEnvInit(context, resourceName, service);
            amplify.saveEnvResourceParameters(context, constants_1.category, resourceName, config);
        };
    });
    const teamProviderInfo = amplify_cli_core_1.stateManager.getTeamProviderInfo();
    const currentAmplifyMeta = amplify_cli_core_1.stateManager.getCurrentMeta();
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const changedResources = [...resourcesToBeCreated, ...resourcesToBeDeleted, ...resourcesToBeUpdated];
    allResources
        .filter(resourceCategoryFilter)
        .filter(r => !changedResources.includes(r))
        .filter(r => r.service === "LambdaLayer")
        .forEach(r => {
        const layerName = r.resourceName;
        const lvmPath = [constants_1.category, layerName, 'layerVersionMap'];
        const currentVersionMap = lodash_1.default.get(currentAmplifyMeta, lvmPath);
        if (layerParams_1.isMultiEnvLayer(context, layerName)) {
            lodash_1.default.set(teamProviderInfo, [envName, 'nonCFNdata', ...lvmPath], currentVersionMap);
            const s3Bucket = lodash_1.default.get(currentAmplifyMeta, [constants_1.category, layerName, 's3Bucket'], {});
            lodash_1.default.set(teamProviderInfo, [envName, 'categories', constants_1.category, layerName], s3Bucket);
        }
        lodash_1.default.set(amplifyMeta, lvmPath, currentVersionMap);
    });
    amplify_cli_core_1.stateManager.setMeta(undefined, amplifyMeta);
    amplify_cli_core_1.stateManager.setTeamProviderInfo(undefined, teamProviderInfo);
    await promise_sequential_1.default(functionTasks);
}
exports.initEnv = initEnv;
async function getInvoker(context, params) {
    const resourcePath = path_1.default.join(context.amplify.pathManager.getBackendDirPath(), constants_1.category, params.resourceName);
    const breadcrumbs = context.amplify.readBreadcrumbs(context, constants_1.category, params.resourceName);
    const runtimeManager = await context.amplify.loadRuntimePlugin(context, breadcrumbs.pluginId);
    const lastBuildTimestampStr = (await context.amplify.getResourceStatus(constants_1.category, params.resourceName)).allResources.find(resource => resource.resourceName === params.resourceName).lastBuildTimeStamp;
    return async (request) => await runtimeManager.invoke({
        handler: params.handler,
        event: JSON.stringify(request.event),
        env: context.amplify.getEnvInfo().envName,
        runtime: breadcrumbs.functionRuntime,
        srcRoot: resourcePath,
        envVars: params.envVars,
        lastBuildTimestamp: lastBuildTimestampStr ? new Date(lastBuildTimestampStr) : undefined,
    });
}
exports.getInvoker = getInvoker;
function isMockable(context, resourceName) {
    const resourceValue = lodash_1.default.get(context.amplify.getProjectMeta(), [constants_1.category, resourceName]);
    if (!resourceValue) {
        return {
            isMockable: false,
            reason: `Could not find the specified ${constants_1.category}: ${resourceName}`,
        };
    }
    const { service, dependsOn } = resourceValue;
    const dependsOnLayers = Array.isArray(dependsOn)
        ? dependsOn
            .filter(dependency => dependency.category === 'function')
            .map(val => lodash_1.default.get(context.amplify.getProjectMeta(), [val.category, val.resourceName]))
            .filter(val => val.service === "LambdaLayer")
        : [];
    const hasLayer = service === "Lambda" && Array.isArray(dependsOnLayers) && dependsOnLayers.length !== 0;
    if (hasLayer) {
        return {
            isMockable: false,
            reason: 'Mocking a function with layers is not supported. ' +
                'To test in the cloud: run "amplify push" to deploy your function to the cloud ' +
                'and then run "amplify console function" to test your function in the Lambda console.',
        };
    }
    return supported_services_1.supportedServices[service].providerController.isMockable(service);
}
exports.isMockable = isMockable;
async function executeAmplifyCommand(context) {
    let commandPath = path_1.default.normalize(path_1.default.join(__dirname, 'commands'));
    if (context.input.command === 'help') {
        commandPath = path_1.default.join(commandPath, constants_1.category);
    }
    else {
        commandPath = path_1.default.join(commandPath, constants_1.category, context.input.command);
    }
    const commandModule = require(commandPath);
    await commandModule.run(context);
}
exports.executeAmplifyCommand = executeAmplifyCommand;
async function handleAmplifyEvent(context, args) {
    context.print.info(`${constants_1.category} handleAmplifyEvent to be implemented`);
    context.print.info(`Received event args ${args}`);
}
exports.handleAmplifyEvent = handleAmplifyEvent;
//# sourceMappingURL=index.js.map