"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = exports.updateWalkthrough = exports.createWalkthrough = void 0;
const generalQuestionsWalkthrough_1 = __importDefault(require("./generalQuestionsWalkthrough"));
const autogeneratedParameters_1 = __importDefault(require("./autogeneratedParameters"));
const functionPluginLoader_1 = require("../utils/functionPluginLoader");
const lodash_1 = __importDefault(require("lodash"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const inquirer_1 = __importDefault(require("inquirer"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../utils/constants");
const constants_2 = require("../../../constants");
const cloudformationHelpers_1 = require("../utils/cloudformationHelpers");
const execPermissionsWalkthrough_1 = require("./execPermissionsWalkthrough");
const scheduleWalkthrough_1 = require("./scheduleWalkthrough");
const funcParamsUtils_1 = require("../utils/funcParamsUtils");
const updateTopLevelComment_1 = require("../utils/updateTopLevelComment");
const addLayerToFunctionWalkthrough_1 = require("./addLayerToFunctionWalkthrough");
const layerArnConverter_1 = require("../utils/layerArnConverter");
const loadFunctionParameters_1 = require("../utils/loadFunctionParameters");
async function createWalkthrough(context, templateParameters) {
    templateParameters = funcParamsUtils_1.merge(templateParameters, autogeneratedParameters_1.default(context));
    templateParameters = funcParamsUtils_1.merge(templateParameters, await generalQuestionsWalkthrough_1.default(context));
    if (!templateParameters.runtime) {
        let runtimeSelection = await functionPluginLoader_1.runtimeWalkthrough(context, templateParameters);
        templateParameters = funcParamsUtils_1.merge(templateParameters, runtimeSelection[0]);
    }
    templateParameters = funcParamsUtils_1.merge(templateParameters, await functionPluginLoader_1.templateWalkthrough(context, templateParameters));
    if (await context.amplify.confirmPrompt('Do you want to access other resources in this project from your Lambda function?')) {
        templateParameters = funcParamsUtils_1.merge(templateParameters, await execPermissionsWalkthrough_1.askExecRolePermissionsQuestions(context, templateParameters.functionName, undefined, templateParameters.environmentMap));
    }
    templateParameters = funcParamsUtils_1.merge(templateParameters, await scheduleWalkthrough_1.scheduleWalkthrough(context, templateParameters));
    templateParameters = funcParamsUtils_1.merge(templateParameters, await addLayerToFunctionWalkthrough_1.addLayersToFunctionWalkthrough(context, templateParameters.runtime));
    return templateParameters;
}
exports.createWalkthrough = createWalkthrough;
async function updateWalkthrough(context, lambdaToUpdate) {
    const lambdaFuncResourceNames = (await context.amplify.getResourceStatus()).allResources
        .filter(resource => resource.service === "Lambda" && !!resource.providerPlugin)
        .map(resource => resource.resourceName);
    if (lambdaFuncResourceNames.length === 0) {
        context.print.error('No Lambda function resource to update. Use "amplify add function" to create a new function.');
        return;
    }
    if (lambdaToUpdate) {
        if (!lambdaFuncResourceNames.includes(lambdaToUpdate)) {
            context.print.error(`No Lambda function named ${lambdaToUpdate} exists in the project.`);
            return;
        }
    }
    else {
        const resourceQuestion = [
            {
                name: 'resourceName',
                message: 'Select the Lambda function you want to update',
                type: 'list',
                choices: lambdaFuncResourceNames,
            },
        ];
        lambdaToUpdate = (await inquirer_1.default.prompt(resourceQuestion)).resourceName;
    }
    const functionParameters = {
        resourceName: lambdaToUpdate,
        environmentMap: {
            ENV: {
                Ref: 'env',
            },
            REGION: {
                Ref: 'AWS::Region',
            },
        },
    };
    const projectBackendDirPath = context.amplify.pathManager.getBackendDirPath();
    const resourceDirPath = path_1.default.join(projectBackendDirPath, constants_2.category, functionParameters.resourceName);
    const currentParameters = loadFunctionParameters_1.loadFunctionParameters(context, resourceDirPath);
    if (await context.amplify.confirmPrompt('Do you want to update the Lambda function permissions to access other resources in this project?')) {
        const additionalParameters = await execPermissionsWalkthrough_1.askExecRolePermissionsQuestions(context, lambdaToUpdate, currentParameters.permissions);
        const currentDependsOn = lodash_1.default.get(context.amplify.getProjectMeta(), ['function', lambdaToUpdate, 'dependsOn'], []);
        if (currentDependsOn.length > 0) {
            additionalParameters.dependsOn = additionalParameters.dependsOn || [];
            currentDependsOn.forEach(dependency => {
                const updatedDependency = additionalParameters.dependsOn.find(d => {
                    return d.category === dependency.category && d.resourceName === dependency.resourceName;
                });
                if (updatedDependency) {
                    updatedDependency.attributes = lodash_1.default.uniqWith(updatedDependency.attributes.concat(dependency.attributes), lodash_1.default.isEqual);
                }
                else {
                    additionalParameters.dependsOn.push(dependency);
                }
            });
        }
        funcParamsUtils_1.merge(functionParameters, additionalParameters);
        const cfnFileName = `${functionParameters.resourceName}-cloudformation-template.json`;
        const cfnFilePath = path_1.default.join(resourceDirPath, cfnFileName);
        const cfnContent = context.amplify.readJsonFile(cfnFilePath);
        const dependsOnParams = { env: { Type: 'String' } };
        Object.keys(functionParameters.environmentMap)
            .filter(key => key !== 'ENV')
            .filter(key => key !== 'REGION')
            .filter(resourceProperty => 'Ref' in functionParameters.environmentMap[resourceProperty])
            .forEach(resourceProperty => {
            dependsOnParams[functionParameters.environmentMap[resourceProperty].Ref] = {
                Type: 'String',
                Default: functionParameters.environmentMap[resourceProperty].Ref,
            };
        });
        cfnContent.Parameters = cloudformationHelpers_1.getNewCFNParameters(cfnContent.Parameters, currentParameters, dependsOnParams, functionParameters.mutableParametersState);
        if (!cfnContent.Resources.AmplifyResourcesPolicy) {
            cfnContent.Resources.AmplifyResourcesPolicy = {
                DependsOn: ['LambdaExecutionRole'],
                Type: 'AWS::IAM::Policy',
                Properties: {
                    PolicyName: 'amplify-lambda-execution-policy',
                    Roles: [
                        {
                            Ref: 'LambdaExecutionRole',
                        },
                    ],
                    PolicyDocument: {
                        Version: '2012-10-17',
                        Statement: [],
                    },
                },
            };
        }
        if (functionParameters.categoryPolicies.length === 0) {
            delete cfnContent.Resources.AmplifyResourcesPolicy;
        }
        else {
            cfnContent.Resources.AmplifyResourcesPolicy.Properties.PolicyDocument.Statement = functionParameters.categoryPolicies;
        }
        cfnContent.Resources.LambdaFunction.Properties.Environment.Variables = cloudformationHelpers_1.getNewCFNEnvVariables(cfnContent.Resources.LambdaFunction.Properties.Environment.Variables, currentParameters, functionParameters.environmentMap, functionParameters.mutableParametersState);
        context.amplify.writeObjectAsJson(cfnFilePath, cfnContent, true);
        updateTopLevelComment_1.tryUpdateTopLevelComment(resourceDirPath, lodash_1.default.keys(functionParameters.environmentMap));
    }
    else {
        functionParameters.dependsOn = lodash_1.default.get(context.amplify.getProjectMeta(), ['function', lambdaToUpdate, 'dependsOn'], []);
    }
    const cfnParameters = context.amplify.readJsonFile(path_1.default.join(resourceDirPath, constants_1.parametersFileName), undefined, false) || {};
    const scheduleParameters = {
        cloudwatchRule: cfnParameters.CloudWatchRule,
        resourceName: functionParameters.resourceName,
    };
    funcParamsUtils_1.merge(functionParameters, await scheduleWalkthrough_1.scheduleWalkthrough(context, scheduleParameters));
    const functionRuntime = context.amplify.readBreadcrumbs(context, constants_2.category, functionParameters.resourceName).functionRuntime;
    const currentFunctionParameters = context.amplify.readJsonFile(path_1.default.join(resourceDirPath, constants_1.functionParametersFileName), undefined, false) || {};
    funcParamsUtils_1.merge(functionParameters, await addLayerToFunctionWalkthrough_1.addLayersToFunctionWalkthrough(context, { value: functionRuntime }, currentFunctionParameters.lambdaLayers));
    const cfnFileName = `${functionParameters.resourceName}-cloudformation-template.json`;
    const cfnFilePath = path_1.default.join(resourceDirPath, cfnFileName);
    const cfnContent = context.amplify.readJsonFile(cfnFilePath);
    functionParameters.lambdaLayers.forEach(layer => {
        const resourceName = lodash_1.default.get(layer, ['resourceName'], null);
        if (resourceName) {
            const param = `function${resourceName}Arn`;
            if (cfnContent.Parameters[`${param}`] === undefined) {
                cfnContent.Parameters[`${param}`] = {
                    Type: 'String',
                    Default: `${param}`,
                };
            }
        }
    });
    cfnContent.Resources.LambdaFunction.Properties.Layers = layerArnConverter_1.convertLambdaLayerMetaToLayerCFNArray(context, functionParameters.lambdaLayers, context.amplify.getEnvInfo().envName);
    context.amplify.writeObjectAsJson(cfnFilePath, cfnContent, true);
    return functionParameters;
}
exports.updateWalkthrough = updateWalkthrough;
function migrate(context, projectPath, resourceName) {
    const resourceDirPath = path_1.default.join(projectPath, 'amplify', 'backend', constants_2.category, resourceName);
    const cfnFilePath = path_1.default.join(resourceDirPath, `${resourceName}-cloudformation-template.json`);
    const oldCfn = context.amplify.readJsonFile(cfnFilePath);
    const newCfn = {};
    Object.assign(newCfn, oldCfn);
    if (!newCfn.Parameters) {
        newCfn.Parameters = {};
    }
    newCfn.Parameters.env = {
        Type: 'String',
    };
    if (!newCfn.Conditions) {
        newCfn.Conditions = {};
    }
    newCfn.Conditions.ShouldNotCreateEnvResources = {
        'Fn::Equals': [
            {
                Ref: 'env',
            },
            'NONE',
        ],
    };
    const oldFunctionName = newCfn.Resources.LambdaFunction.Properties.FunctionName;
    newCfn.Resources.LambdaFunction.Properties.FunctionName = {
        'Fn::If': [
            'ShouldNotCreateEnvResources',
            oldFunctionName,
            {
                'Fn::Join': [
                    '',
                    [
                        oldFunctionName,
                        '-',
                        {
                            Ref: 'env',
                        },
                    ],
                ],
            },
        ],
    };
    newCfn.Resources.LambdaFunction.Properties.Environment = { Variables: { ENV: { Ref: 'env' } } };
    const oldRoleName = newCfn.Resources.LambdaExecutionRole.Properties.RoleName;
    newCfn.Resources.LambdaExecutionRole.Properties.RoleName = {
        'Fn::If': [
            'ShouldNotCreateEnvResources',
            oldRoleName,
            {
                'Fn::Join': [
                    '',
                    [
                        oldRoleName,
                        '-',
                        {
                            Ref: 'env',
                        },
                    ],
                ],
            },
        ],
    };
    const jsonString = JSON.stringify(newCfn, null, '\t');
    fs_extra_1.default.writeFileSync(cfnFilePath, jsonString, 'utf8');
}
exports.migrate = migrate;
//# sourceMappingURL=lambda-walkthrough.js.map