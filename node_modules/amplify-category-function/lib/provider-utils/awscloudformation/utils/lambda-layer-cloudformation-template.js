"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateLayerCfnObj = void 0;
const cloudform_types_1 = require("cloudform-types");
const lodash_1 = __importDefault(require("lodash"));
const lambda_1 = __importDefault(require("cloudform-types/types/lambda"));
const layerParams_1 = require("./layerParams");
function generateLayerCfnObjBase(multiEnvLayer) {
    const cfnObj = {
        AWSTemplateFormatVersion: '2010-09-09',
        Description: 'Lambda layer resource stack creation using Amplify CLI',
        Parameters: {
            layerVersion: {
                Type: 'String',
                Default: '1',
            },
            env: {
                Type: 'String',
            },
        },
        Resources: {},
        Conditions: {
            HasEnvironmentParameter: cloudform_types_1.Fn.Not(cloudform_types_1.Fn.Equals(cloudform_types_1.Fn.Ref('env'), 'NONE')),
        },
    };
    if (multiEnvLayer) {
        lodash_1.default.merge(cfnObj, {
            Parameters: {
                s3Key: {
                    Type: 'String',
                },
                deploymentBucketName: {
                    Type: 'String',
                },
            },
        });
    }
    return cfnObj;
}
function generateLayerCfnObj(context, parameters) {
    const multiEnvLayer = layerParams_1.isMultiEnvLayer(context, parameters.layerName);
    const layerData = layerParams_1.getLayerMetadataFactory(context)(parameters.layerName);
    const outputObj = {
        Outputs: {
            Arn: {
                Value: cloudform_types_1.Fn.Ref('LambdaLayer'),
            },
            Region: { Value: cloudform_types_1.Refs.Region },
        },
    };
    let cfnObj = { ...generateLayerCfnObjBase(multiEnvLayer), ...outputObj };
    const POLICY_RETAIN = cloudform_types_1.DeletionPolicy.Retain;
    const layerName = multiEnvLayer ? cloudform_types_1.Fn.Sub(`${parameters.layerName}-` + '${env}', { env: cloudform_types_1.Fn.Ref('env') }) : parameters.layerName;
    const layer = new lambda_1.default.LayerVersion({
        CompatibleRuntimes: parameters.runtimes.map(runtime => runtime.cloudTemplateValue),
        Content: {
            S3Bucket: cloudform_types_1.Fn.Ref('deploymentBucketName'),
            S3Key: cloudform_types_1.Fn.Ref('s3Key'),
        },
        Description: cloudform_types_1.Fn.Sub('Lambda layer version ${latestVersion}', { latestVersion: cloudform_types_1.Fn.Ref('layerVersion') }),
        LayerName: layerName,
    });
    layer.deletionPolicy(POLICY_RETAIN);
    lodash_1.default.assign(layer, { UpdateReplacePolicy: POLICY_RETAIN });
    cfnObj.Resources['LambdaLayer'] = layer;
    Object.entries(parameters.layerVersionMap).forEach(([key]) => {
        const answer = assignLayerPermissions(layerData, key, parameters.layerName, parameters.build, multiEnvLayer);
        answer.forEach(permission => (cfnObj.Resources[permission.name] = permission.policy));
    });
    return cfnObj;
}
exports.generateLayerCfnObj = generateLayerCfnObj;
function assignLayerPermissions(layerData, version, layerName, isContentUpdated, multiEnvLayer) {
    const layerVersionPermissionBase = {
        Action: 'lambda:GetLayerVersion',
        LayerVersionArn: createLayerVersionArn(layerData, layerName, version, isContentUpdated, multiEnvLayer),
    };
    const result = [];
    const versionPermission = layerData.getVersion(Number(version));
    if (versionPermission.isPublic()) {
        result.push({
            name: `LambdaLayerPermission${layerParams_1.Permission.public}${version}`,
            policy: new lambda_1.default.LayerVersionPermission({
                ...layerVersionPermissionBase,
                Principal: '*',
            }),
        });
        return result;
    }
    if (versionPermission.isPrivate()) {
        result.push({
            name: `LambdaLayerPermission${layerParams_1.Permission.private}${version}`,
            policy: new lambda_1.default.LayerVersionPermission({
                ...layerVersionPermissionBase,
                Principal: cloudform_types_1.Refs.AccountId,
            }),
        });
    }
    const accountIds = versionPermission.listAccountAccess();
    const orgIds = versionPermission.listOrgAccess();
    accountIds.forEach(acctId => result.push({
        name: `LambdaLayerPermission${layerParams_1.Permission.awsAccounts}${acctId}${version}`,
        policy: new lambda_1.default.LayerVersionPermission({
            ...layerVersionPermissionBase,
            Principal: acctId,
        }),
    }));
    orgIds.forEach(orgId => result.push({
        name: `LambdaLayerPermission${layerParams_1.Permission.awsOrg}${orgId.replace('-', '')}${version}`,
        policy: new lambda_1.default.LayerVersionPermission({
            ...layerVersionPermissionBase,
            Principal: '*',
            OrganizationId: orgId,
        }),
    }));
    return result;
}
function createLayerVersionArn(layerData, layerName, version, isContentUpdated, multiEnvLayer) {
    if (isContentUpdated) {
        if (layerData.getLatestVersion() === Number(version)) {
            return cloudform_types_1.Fn.Ref('LambdaLayer');
        }
    }
    if (multiEnvLayer) {
        return cloudform_types_1.Fn.Sub('arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:${layerName}-${env}:${layerVersion}', {
            layerName,
            env: cloudform_types_1.Fn.Ref('env'),
            layerVersion: version,
        });
    }
    return cloudform_types_1.Fn.Sub('arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:${layerName}:${layerVersion}', {
        layerName,
        layerVersion: version,
    });
}
//# sourceMappingURL=lambda-layer-cloudformation-template.js.map