"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.layerInputParamsToLayerPermissionArray = exports.chooseParamsOnEnvInit = exports.previousPermissionsQuestion = exports.layerOrgAccessQuestion = exports.layerAccountAccessQuestion = exports.layerPermissionsQuestion = exports.layerNameQuestion = exports.layerVersionQuestion = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const inquirer_1 = require("inquirer");
const lodash_1 = __importDefault(require("lodash"));
const uuid_1 = __importDefault(require("uuid"));
const constants_1 = require("./constants");
const layerParams_1 = require("../utils/layerParams");
function layerVersionQuestion(versions) {
    return [
        {
            type: 'list',
            name: 'layerVersion',
            message: 'Select the layer version to update:',
            choices: versions,
        },
    ];
}
exports.layerVersionQuestion = layerVersionQuestion;
function layerNameQuestion(context) {
    return [
        {
            type: 'input',
            name: 'layerName',
            message: 'Provide a name for your Lambda layer:',
            validate: input => {
                input = input.trim();
                const meta = context.amplify.getProjectMeta();
                if (!/^[a-zA-Z0-9]{1,129}$/.test(input)) {
                    return 'Lambda layer names must be 1-129 alphanumeric characters.';
                }
                else if (meta.function && meta.function.hasOwnProperty(input)) {
                    return `A Lambda layer with the name ${input} already exists in this project.`;
                }
                return true;
            },
            default: () => {
                const appName = context.amplify
                    .getProjectDetails()
                    .projectConfig.projectName.toLowerCase()
                    .replace(/[^a-zA-Z0-9]/gi, '');
                const [shortId] = uuid_1.default().split('-');
                return `${appName}${shortId}`;
            },
        },
    ];
}
exports.layerNameQuestion = layerNameQuestion;
function layerPermissionsQuestion(params) {
    return [
        {
            type: 'checkbox',
            name: 'layerPermissions',
            message: 'The current AWS account will always have access to this layer.\nOptionally, configure who else can access this layer. (Hit <Enter> to skip)',
            choices: [
                {
                    name: 'Specific AWS accounts',
                    value: layerParams_1.Permission.awsAccounts,
                    checked: lodash_1.default.includes(params, layerParams_1.Permission.awsAccounts),
                },
                {
                    name: 'Specific AWS organization',
                    value: layerParams_1.Permission.awsOrg,
                    checked: lodash_1.default.includes(params, layerParams_1.Permission.awsOrg),
                },
                {
                    name: 'Public (Anyone on AWS can use this layer)',
                    short: 'Public',
                    value: layerParams_1.Permission.public,
                    checked: lodash_1.default.includes(params, layerParams_1.Permission.public),
                },
            ],
            default: [layerParams_1.Permission.private],
        },
    ];
}
exports.layerPermissionsQuestion = layerPermissionsQuestion;
function layerAccountAccessQuestion(defaultAccountIds) {
    const hasDefaults = defaultAccountIds && defaultAccountIds.length > 0;
    return [
        {
            type: 'input',
            name: 'authorizedAccountIds',
            message: 'Provide a list of comma-separated AWS account IDs:',
            validate: (input) => {
                const accounts = input.split(',');
                const set = new Set();
                for (let accountID of accounts) {
                    accountID = accountID.trim();
                    if (!/^[0-9]{12}$/.test(accountID)) {
                        return `AWS account IDs must be 12 digits long. ${accountID} did not match the criteria.`;
                    }
                    if (set.has(accountID)) {
                        return `Duplicate ID detected: ${accountID}`;
                    }
                    set.add(accountID);
                }
                return true;
            },
            default: hasDefaults ? defaultAccountIds.join(',') : undefined,
        },
    ];
}
exports.layerAccountAccessQuestion = layerAccountAccessQuestion;
function layerOrgAccessQuestion(defaultOrgs) {
    const hasDefaults = defaultOrgs && defaultOrgs.length > 0;
    return [
        {
            type: 'input',
            name: 'authorizedOrgId',
            message: 'Provide a list of comma-separated AWS organization IDs:',
            validate: input => {
                const orgIds = input.split(',');
                const set = new Set();
                for (let orgId of orgIds) {
                    orgId = orgId.trim();
                    if (!/^o-[a-zA-Z0-9]{10,32}$/.test(orgId)) {
                        return 'The organization ID starts with "o-" followed by a 10-32 character-long alphanumeric string.';
                    }
                    if (set.has(orgId)) {
                        return `Duplicate ID detected: ${orgId}`;
                    }
                    set.add(orgId);
                }
                return true;
            },
            default: hasDefaults ? defaultOrgs.join(',') : undefined,
        },
    ];
}
exports.layerOrgAccessQuestion = layerOrgAccessQuestion;
function previousPermissionsQuestion(layerName) {
    return [
        {
            type: 'list',
            name: 'usePreviousPermissions',
            message: 'What permissions do you want to grant to this new layer version?',
            choices: [
                {
                    name: 'The same permission as the latest layer version',
                    short: 'Previous version permissions',
                    value: true,
                },
                {
                    name: 'Only accessible by the current account. You can always edit this later with: amplify update function',
                    short: 'Private',
                    value: false,
                },
            ],
            default: 0,
        },
    ];
}
exports.previousPermissionsQuestion = previousPermissionsQuestion;
async function chooseParamsOnEnvInit(context, layerName) {
    const teamProviderInfoPath = context.amplify.pathManager.getProviderInfoFilePath();
    const teamProviderInfo = amplify_cli_core_1.JSONUtilities.readJson(teamProviderInfoPath);
    const filteredEnvs = Object.keys(teamProviderInfo).filter(env => lodash_1.default.has(teamProviderInfo, [env, 'nonCFNdata', constants_1.categoryName, layerName, 'layerVersionMap']));
    const currentEnv = context.amplify.getEnvInfo().envName;
    if (filteredEnvs.includes(currentEnv)) {
        return lodash_1.default.get(teamProviderInfo, [currentEnv, 'nonCFNdata', constants_1.categoryName, layerName]);
    }
    context.print.info(`Adding Lambda layer ${layerName} to ${currentEnv} environment.`);
    const yesFlagSet = lodash_1.default.get(context, ['parameters', 'options', 'yes'], false);
    let envName;
    if (!yesFlagSet) {
        envName = (await inquirer_1.prompt(chooseParamsOnEnvInitQuestion(layerName, filteredEnvs))).envName;
    }
    const defaultPermission = [{ type: 'private' }];
    if (yesFlagSet || envName === undefined) {
        return {
            runtimes: [],
            layerVersionMap: {
                1: {
                    permissions: defaultPermission,
                },
            },
        };
    }
    const layerToCopy = teamProviderInfo[envName].nonCFNdata.function[layerName];
    const latestVersion = Math.max(...Object.keys(layerToCopy.layerVersionMap || {}).map(v => Number(v)));
    const permissions = latestVersion ? layerToCopy.layerVersionMap[latestVersion].permissions : defaultPermission;
    return {
        runtimes: layerToCopy.runtimes,
        layerVersionMap: {
            1: { permissions },
        },
    };
}
exports.chooseParamsOnEnvInit = chooseParamsOnEnvInit;
function chooseParamsOnEnvInitQuestion(layerName, filteredEnvs) {
    const choices = filteredEnvs
        .map(env => ({ name: env, value: env }))
        .concat([{ name: 'Apply default access (Only this AWS account)', value: undefined }]);
    return [
        {
            type: 'list',
            name: 'envName',
            message: `Choose the environment to import the layer access settings from:`,
            choices,
        },
    ];
}
function layerInputParamsToLayerPermissionArray(parameters) {
    const { layerPermissions } = parameters;
    let permissionObj = [];
    if (layerPermissions !== undefined && layerPermissions.length > 0) {
        layerPermissions.forEach(val => {
            let obj;
            if (val === layerParams_1.Permission.public) {
                obj = {
                    type: layerParams_1.Permission.public,
                };
            }
            else if (val === layerParams_1.Permission.awsOrg) {
                obj = {
                    type: layerParams_1.Permission.awsOrg,
                    orgs: parameters.authorizedOrgId.split(','),
                };
            }
            else if (val === layerParams_1.Permission.awsAccounts) {
                obj = {
                    type: layerParams_1.Permission.awsAccounts,
                    accounts: parameters.authorizedAccountIds.split(','),
                };
            }
            permissionObj.push(obj);
        });
    }
    const privateObj = {
        type: layerParams_1.Permission.private,
    };
    permissionObj.push(privateObj);
    return permissionObj;
}
exports.layerInputParamsToLayerPermissionArray = layerInputParamsToLayerPermissionArray;
//# sourceMappingURL=layerHelpers.js.map