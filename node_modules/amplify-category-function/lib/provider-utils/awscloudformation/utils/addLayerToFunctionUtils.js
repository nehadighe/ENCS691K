"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.askLayerOrderQuestion = exports.askCustomArnQuestion = exports.askLayerSelection = exports.provideExistingARNsPrompt = void 0;
const lodash_1 = __importDefault(require("lodash"));
const __1 = require("../../..");
const inquirer_1 = __importDefault(require("inquirer"));
const enquirer_1 = __importDefault(require("enquirer"));
const layerRuntimes_1 = require("./layerRuntimes");
const layerSelectionPrompt = 'Provide existing layers or select layers in this project to access from this function (pick up to 5):';
exports.provideExistingARNsPrompt = 'Provide existing Lambda layer ARNs';
const versionSelectionPrompt = (layerName) => `Select a version for ${layerName}:`;
const ARNEntryPrompt = (remainingLayers) => `Enter up to ${remainingLayers} existing Lambda layer ARNs (comma-separated):`;
const layerOrderPrompt = 'Modify the layer order (Layers with conflicting files will overwrite contents of layers earlier in the list):';
const layerARNRegex = /^arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:\d+$/;
exports.askLayerSelection = async (layerMetadataFactory, amplifyMeta, runtimeValue, previousSelections = [], backendDir) => {
    const lambdaLayers = [];
    const dependsOn = [];
    const functionMeta = lodash_1.default.get(amplifyMeta, [__1.category]) || {};
    const layerOptions = lodash_1.default.keys(functionMeta)
        .filter(key => functionMeta[key].service === "LambdaLayer")
        .filter(key => {
        return isRuntime(runtimeValue).inRuntimes(functionMeta[key].runtimes || layerRuntimes_1.getLayerRuntimes(backendDir, key));
    });
    if (layerOptions.length === 0) {
        return {
            lambdaLayers,
            dependsOn,
            askArnQuestion: true,
        };
    }
    const currentResourceNames = filterProjectLayers(previousSelections).map(sel => sel.resourceName);
    const choices = layerOptions.map(op => ({ name: op, checked: currentResourceNames.includes(op) }));
    choices.unshift({ name: exports.provideExistingARNsPrompt, checked: previousSelections.map(sel => sel.type).includes('ExternalLayer') });
    const layerSelectionQuestion = {
        type: 'checkbox',
        name: 'layerSelections',
        message: layerSelectionPrompt,
        choices: choices,
        validate: (input) => input.length <= 5 || 'Select at most 5 entries from the list',
    };
    let layerSelections = (await inquirer_1.default.prompt(layerSelectionQuestion)).layerSelections;
    const askArnQuestion = layerSelections.includes(exports.provideExistingARNsPrompt);
    layerSelections = layerSelections.filter(selection => selection !== exports.provideExistingARNsPrompt);
    for (let selection of layerSelections) {
        const currentSelectionDefaults = filterProjectLayers(previousSelections).find(sel => sel.resourceName === selection);
        const currentVersion = currentSelectionDefaults ? currentSelectionDefaults.version.toString() : undefined;
        const layerState = layerMetadataFactory(selection);
        await layerState.syncVersions();
        const layerVersionPrompt = {
            type: 'list',
            name: 'versionSelection',
            message: versionSelectionPrompt(selection),
            choices: layerState.listVersions().map(num => num.toString()),
            default: currentVersion,
            filter: numStr => parseInt(numStr, 10),
        };
        const versionSelection = (await inquirer_1.default.prompt(layerVersionPrompt)).versionSelection;
        lambdaLayers.push({
            type: 'ProjectLayer',
            resourceName: selection,
            version: versionSelection,
        });
        dependsOn.push({
            category: __1.category,
            resourceName: selection,
            attributes: ['Arn'],
        });
    }
    return {
        lambdaLayers,
        dependsOn,
        askArnQuestion,
    };
};
exports.askCustomArnQuestion = async (numLayersSelected, previousSelections = []) => {
    const arnPrompt = {
        type: 'input',
        name: 'arns',
        message: ARNEntryPrompt(5 - numLayersSelected),
        validate: lambdaLayerARNValidator,
        filter: stringSplitAndTrim,
        default: filterExternalLayers(previousSelections)
            .map(sel => sel.arn)
            .join(', ') || undefined,
    };
    return (await inquirer_1.default.prompt(arnPrompt)).arns.map(arn => ({ type: 'ExternalLayer', arn }));
};
exports.askLayerOrderQuestion = async (currentSelections, previousSelections = []) => {
    if (currentSelections.length <= 1) {
        return currentSelections;
    }
    previousSelections.reverse().forEach(prevSel => {
        let idx = -1;
        switch (prevSel.type) {
            case 'ExternalLayer':
                idx = currentSelections.findIndex(currSel => currSel.type === 'ExternalLayer' && currSel.arn === prevSel.arn);
                break;
            default:
                idx = currentSelections.findIndex(currSel => currSel.type === 'ProjectLayer' && currSel.resourceName === prevSel.resourceName);
        }
        if (idx >= 0) {
            currentSelections.unshift(...currentSelections.splice(idx, 1));
        }
    });
    const sortPrompt = {
        type: 'sort',
        name: 'sortedNames',
        message: layerOrderPrompt,
        choices: currentSelections.map(ll => (ll.type === 'ExternalLayer' ? ll.arn : ll.resourceName)),
    };
    const sortedNames = (await enquirer_1.default.prompt(sortPrompt)).sortedNames;
    const finalSelectionOrder = [];
    sortedNames.forEach(name => finalSelectionOrder.push(currentSelections.find(sel => (sel.type === 'ExternalLayer' ? sel.arn === name : sel.resourceName === name))));
    return finalSelectionOrder;
};
const isRuntime = (runtime) => ({
    inRuntimes: (runtimes) => runtimes.map(runtime => runtime.value).includes(runtime),
});
const filterProjectLayers = (layers) => {
    return layers.filter(layer => layer.type === 'ProjectLayer');
};
const filterExternalLayers = (layers) => {
    return layers.filter(layer => layer.type === 'ExternalLayer');
};
const stringSplitAndTrim = (input) => {
    return input
        .split(',')
        .map(str => str.trim())
        .filter(str => str);
};
const lambdaLayerARNValidator = (input) => {
    const invalidARNs = input.filter(arn => !arn.match(layerARNRegex));
    return invalidARNs.length === 0 ? true : `${invalidARNs.join(', ')} are not valid Lambda layer ARNs`;
};
//# sourceMappingURL=addLayerToFunctionUtils.js.map