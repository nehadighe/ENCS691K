"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMockable = exports.openConsole = exports.updateConfigOnEnvInit = exports.getPermissionPolicies = exports.migrateResource = exports.updateFunctionResource = exports.updateLayerResource = exports.updateResource = exports.addLayerResource = exports.addFunctionResource = exports.addResource = void 0;
const layerParams_1 = require("./utils/layerParams");
const layerHelpers_1 = require("./utils/layerHelpers");
const supported_services_1 = require("../supported-services");
const constants_1 = require("./utils/constants");
const constants_2 = require("../../constants");
const storeResources_1 = require("./utils/storeResources");
const layerRuntimes_1 = require("./utils/layerRuntimes");
const lodash_1 = __importDefault(require("lodash"));
const funcParamsUtils_1 = require("./utils/funcParamsUtils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const open_1 = __importDefault(require("open"));
async function addResource(context, category, service, options, parameters) {
    const serviceConfig = supported_services_1.supportedServices[service];
    const BAD_SERVICE_ERR = new Error(`amplify-category-function is not configured to provide service type ${service}`);
    if (!serviceConfig) {
        throw BAD_SERVICE_ERR;
    }
    switch (service) {
        case "Lambda":
            return addFunctionResource(context, category, service, serviceConfig, parameters);
        case "LambdaLayer":
            return addLayerResource(context, service, serviceConfig, parameters);
        default:
            throw BAD_SERVICE_ERR;
    }
}
exports.addResource = addResource;
async function addFunctionResource(context, category, service, serviceConfig, parameters) {
    let completeParams;
    if (!parameters || (!funcParamsUtils_1.isComplete(parameters) && !('trigger' in parameters))) {
        let funcParams = {
            providerContext: {
                provider: constants_1.provider,
                service: service,
                projectName: context.amplify.getProjectDetails().projectConfig.projectName,
            },
        };
        funcParams = funcParamsUtils_1.merge(funcParams, parameters);
        funcParams = funcParamsUtils_1.merge(funcParams, { cloudResourceTemplatePath: serviceConfig.cfnFilename });
        funcParams = funcParamsUtils_1.merge(funcParams, {
            environmentMap: {
                ENV: {
                    Ref: 'env',
                },
                REGION: {
                    Ref: 'AWS::Region',
                },
            },
        });
        funcParams = funcParamsUtils_1.merge(funcParams, { lambdaLayers: [] });
        await serviceConfig.walkthroughs.createWalkthrough(context, funcParams);
        completeParams = funcParamsUtils_1.convertToComplete(funcParams);
    }
    else {
        completeParams = parameters;
    }
    storeResources_1.createFunctionResources(context, completeParams);
    if (!completeParams.skipEdit) {
        await openEditor(context, category, completeParams.resourceName, completeParams.functionTemplate);
    }
    const { print } = context;
    print.success(`Successfully added resource ${completeParams.resourceName} locally.`);
    print.info('');
    print.success('Next steps:');
    print.info(`Check out sample function code generated in <project-dir>/amplify/backend/function/${completeParams.resourceName}/src`);
    print.info('"amplify function build" builds all of your functions currently in the project');
    print.info('"amplify mock function <functionName>" runs your function locally');
    print.info('"amplify push" builds all of your local backend resources and provisions them in the cloud');
    print.info('"amplify publish" builds all of your local backend and front-end resources (if you added hosting category) and provisions them in the cloud');
    return completeParams.resourceName;
}
exports.addFunctionResource = addFunctionResource;
async function addLayerResource(context, service, serviceConfig, parameters = {}) {
    parameters.providerContext = {
        provider: constants_1.provider,
        service: service,
        projectName: context.amplify.getProjectDetails().projectConfig.projectName,
    };
    const completeParams = (await serviceConfig.walkthroughs.createWalkthrough(context, parameters));
    storeResources_1.createLayerArtifacts(context, completeParams);
    printLayerSuccessMessages(context, completeParams, 'created');
    return completeParams.layerName;
}
exports.addLayerResource = addLayerResource;
async function updateResource(context, category, service, parameters, resourceToUpdate) {
    const serviceConfig = supported_services_1.supportedServices[service];
    const BAD_SERVICE_ERR = new Error(`amplify-category-function is not configured to provide service type ${service}`);
    if (!serviceConfig) {
        throw BAD_SERVICE_ERR;
    }
    switch (service) {
        case "Lambda":
            return updateFunctionResource(context, category, service, parameters, resourceToUpdate);
        case "LambdaLayer":
            return updateLayerResource(context, service, serviceConfig, parameters);
        default:
            throw BAD_SERVICE_ERR;
    }
}
exports.updateResource = updateResource;
async function updateLayerResource(context, service, serviceConfig, parameters) {
    if (!serviceConfig) {
        throw `amplify-category-function is not configured to provide service type ${service}`;
    }
    if (!parameters) {
        parameters = {};
        parameters.providerContext = {
            provider: constants_1.provider,
            service: service,
            projectName: context.amplify.getProjectDetails().projectConfig.projectName,
        };
    }
    const completeParams = (await serviceConfig.walkthroughs.updateWalkthrough(context, undefined, parameters));
    storeResources_1.updateLayerArtifacts(context, completeParams);
    printLayerSuccessMessages(context, completeParams, 'updated');
}
exports.updateLayerResource = updateLayerResource;
async function updateFunctionResource(context, category, service, parameters, resourceToUpdate) {
    const serviceConfig = supported_services_1.supportedServices[service];
    if (!serviceConfig) {
        throw `amplify-category-function is not configured to provide service type ${service}`;
    }
    if (parameters && 'trigger' in parameters) {
        const parametersFilePath = path_1.default.join(context.amplify.pathManager.getBackendDirPath(), constants_2.category, resourceToUpdate, constants_1.parametersFileName);
        let previousParameters;
        if (fs_extra_1.default.existsSync(parametersFilePath)) {
            previousParameters = context.amplify.readJsonFile(parametersFilePath);
            if ('trigger' in previousParameters) {
                parameters = lodash_1.default.assign(parameters, previousParameters);
            }
        }
        storeResources_1.saveMutableState(context, parameters);
    }
    else {
        parameters = await serviceConfig.walkthroughs.updateWalkthrough(context, parameters, resourceToUpdate);
        if (parameters.dependsOn) {
            context.amplify.updateamplifyMetaAfterResourceUpdate(category, parameters.resourceName, 'dependsOn', parameters.dependsOn);
        }
        storeResources_1.saveMutableState(context, parameters);
        storeResources_1.saveCFNParameters(context, parameters);
    }
    if (!parameters || (parameters && !parameters.skipEdit)) {
        const breadcrumb = context.amplify.readBreadcrumbs(context, constants_2.category, parameters.resourceName);
        const displayName = 'trigger' in parameters ? parameters.resourceName : undefined;
        await openEditor(context, category, parameters.resourceName, { defaultEditorFile: breadcrumb.defaultEditorFile }, displayName);
    }
    return parameters.resourceName;
}
exports.updateFunctionResource = updateFunctionResource;
function printLayerSuccessMessages(context, parameters, action) {
    const { print } = context;
    const { layerName } = parameters;
    const relativeDirPath = path_1.default.join('amplify', 'backend', 'function', layerName);
    print.info(`âœ… Lambda layer folders & files ${action}:`);
    print.info(relativeDirPath);
    print.info('');
    print.success('Next steps:');
    if (parameters.runtimes.length !== 0) {
        print.info('Move your libraries to the following folder:');
        for (let runtime of parameters.runtimes) {
            let runtimePath = path_1.default.join(relativeDirPath, 'lib', runtime.layerExecutablePath);
            print.info(`[${runtime.name}]: ${runtimePath}`);
        }
        print.info('');
    }
    print.info('Include any files you want to share across runtimes in this folder:');
    print.info(path_1.default.join(relativeDirPath, 'opt'));
    print.info('');
    print.info('"amplify function update <function-name>" - configure a function with this Lambda layer');
    print.info('"amplify push" - builds all of your local backend resources and provisions them in the cloud');
}
async function openEditor(context, category, resourceName, template, displayName = 'local') {
    const targetDir = context.amplify.pathManager.getBackendDirPath();
    if (await context.amplify.confirmPrompt(`Do you want to edit the ${displayName} lambda function now?`)) {
        let targetFile = '';
        if (template) {
            if (template.defaultEditorFile) {
                targetFile = template.defaultEditorFile;
            }
            else if (template.sourceFiles && template.sourceFiles.length > 0) {
                const srcFile = template.sourceFiles[0];
                targetFile = lodash_1.default.get(template, ['destMap', srcFile], srcFile);
            }
        }
        const target = path_1.default.join(targetDir, category, resourceName, targetFile);
        await context.amplify.openEditor(context, target);
    }
}
function migrateResource(context, projectPath, service, resourceName) {
    const serviceConfig = supported_services_1.supportedServices[service];
    if (!serviceConfig.walkthroughs.migrate) {
        context.print.info(`No migration required for ${resourceName}`);
        return;
    }
    return serviceConfig.walkthroughs.migrate(context, projectPath, resourceName);
}
exports.migrateResource = migrateResource;
function getPermissionPolicies(context, service, resourceName, crudOptions) {
    const serviceConfig = supported_services_1.supportedServices[service];
    if (!serviceConfig.walkthroughs.getIAMPolicies) {
        context.print.info(`No policies found for ${resourceName}`);
        return;
    }
    return serviceConfig.walkthroughs.getIAMPolicies(resourceName, crudOptions);
}
exports.getPermissionPolicies = getPermissionPolicies;
function isInHeadlessMode(context) {
    return context.exeInfo.inputParams.yes;
}
function getHeadlessParams(context, resourceName) {
    const { inputParams = {} } = context.exeInfo;
    return inputParams.categories && inputParams.categories.function && Array.isArray(inputParams.categories.function)
        ? inputParams.categories.function.find(i => i.resourceName === resourceName) || {}
        : {};
}
async function updateConfigOnEnvInit(context, resourceName, service) {
    if (service === "Lambda") {
        const srvcMetaData = supported_services_1.supportedServices[service];
        const providerPlugin = context.amplify.getPluginInstance(context, srvcMetaData.provider);
        const functionParametersPath = path_1.default.join(context.amplify.pathManager.getBackendDirPath(), constants_2.category, resourceName, 'function-parameters.json');
        let resourceParams = {};
        const functionParametersExists = fs_extra_1.default.existsSync(functionParametersPath);
        if (functionParametersExists) {
            resourceParams = context.amplify.readJsonFile(functionParametersPath);
        }
        let envParams = {};
        if (isInHeadlessMode(context)) {
            const functionParams = getHeadlessParams(context, resourceName);
            return functionParams;
        }
        if (resourceParams.trigger === true) {
            envParams = await initTriggerEnvs(context, resourceParams, providerPlugin, envParams, srvcMetaData);
        }
        return envParams;
    }
    else if (layerParams_1.isMultiEnvLayer(context, resourceName) && service === "LambdaLayer") {
        const teamProviderParams = await layerHelpers_1.chooseParamsOnEnvInit(context, resourceName);
        const providerContext = {
            provider: constants_1.provider,
            service,
            projectName: context.amplify.getProjectDetails().projectConfig.projectName,
        };
        const layerEnvParams = {
            ...teamProviderParams,
            build: true,
            layerName: resourceName,
            providerContext,
            runtimes: layerRuntimes_1.getLayerRuntimes(context.amplify.pathManager.getBackendDirPath(), resourceName),
        };
        storeResources_1.updateLayerArtifacts(context, layerEnvParams, 1);
    }
}
exports.updateConfigOnEnvInit = updateConfigOnEnvInit;
async function initTriggerEnvs(context, resourceParams, providerPlugin, envParams, srvcMetaData) {
    if (resourceParams && resourceParams.parentStack && resourceParams.parentResource) {
        const parentResourceParams = providerPlugin.loadResourceParameters(context, resourceParams.parentStack, resourceParams.parentResource);
        const triggers = typeof parentResourceParams.triggers === 'string' ? JSON.parse(parentResourceParams.triggers) : parentResourceParams.triggers;
        const currentTrigger = resourceParams.resourceName.replace(parentResourceParams.resourceName, '');
        if (currentTrigger && currentTrigger !== resourceParams.resourceName) {
            const currentEnvVariables = context.amplify.loadEnvResourceParameters(context, 'function', resourceParams.resourceName);
            const triggerPath = `${__dirname}/../../../../amplify-category-${resourceParams.parentStack}/provider-utils/${srvcMetaData.provider}/triggers/${currentTrigger}`;
            const isEnvCommand = context.input.command === 'env';
            if (!isEnvCommand) {
                envParams = await context.amplify.getTriggerEnvInputs(context, triggerPath, currentTrigger, triggers[currentTrigger], currentEnvVariables);
            }
            else {
                envParams = currentEnvVariables;
            }
        }
    }
    return envParams;
}
function openConsole(context, service) {
    const amplifyMeta = context.amplify.getProjectMeta();
    const region = amplifyMeta.providers[constants_1.provider].Region;
    const selection = service === "Lambda" ? 'functions' : 'layers';
    const url = `https://${region}.console.aws.amazon.com/lambda/home?region=${region}#/${selection}`;
    open_1.default(url, { wait: false });
}
exports.openConsole = openConsole;
function isMockable(service) {
    return {
        isMockable: service === "Lambda",
        reason: 'Lambda layers cannot be mocked locally',
    };
}
exports.isMockable = isMockable;
//# sourceMappingURL=index.js.map