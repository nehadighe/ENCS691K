"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packageResource = exports.buildResource = exports.checkDependencies = exports.buildResourceInternal = exports.executeCommand = void 0;
const which = __importStar(require("which"));
const execa_1 = __importDefault(require("execa"));
const archiver_1 = __importDefault(require("archiver"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const semver_1 = require("semver");
const constants_1 = require("./constants");
const executableName = 'go';
const minimumVersion = semver_1.coerce('1.0');
const maximumVersion = semver_1.coerce('2.0');
let executablePath;
exports.executeCommand = (args, streamStdio, env = {}, cwd = undefined, stdioInput = undefined) => {
    const output = execa_1.default.sync(executableName, args, {
        stdio: streamStdio === true ? 'inherit' : 'pipe',
        env,
        cwd,
        input: stdioInput,
    });
    if (output.exitCode !== 0) {
        throw new Error(`${executableName} failed, exit code was ${output.exitCode}`);
    }
    return output.stdout;
};
const isBuildStale = (resourceDir, lastBuildTimestamp, outDir) => {
    if (!fs_extra_1.default.existsSync(outDir) || glob_1.default.sync(`${outDir}/**`).length == 0) {
        return true;
    }
    const srcDir = path_1.default.join(resourceDir, constants_1.SRC);
    const dirTime = new Date(fs_extra_1.default.statSync(srcDir).mtime);
    if (dirTime > lastBuildTimestamp) {
        return true;
    }
    const fileUpdatedAfterLastBuild = glob_1.default
        .sync(`${resourceDir}/${constants_1.SRC}/**`)
        .find(file => new Date(fs_extra_1.default.statSync(file).mtime) > lastBuildTimestamp);
    return !!fileUpdatedAfterLastBuild;
};
exports.buildResourceInternal = async (request, context, force, forLocalInvoke) => {
    let rebuilt = false;
    const buildDir = forLocalInvoke === true ? constants_1.BIN_LOCAL : constants_1.BIN;
    const outDir = path_1.default.join(request.srcRoot, buildDir);
    const isWindows = /^win/.test(process.platform);
    const executableName = isWindows && forLocalInvoke ? constants_1.MAIN_BINARY_WIN : constants_1.MAIN_BINARY;
    const executablePath = path_1.default.join(outDir, executableName);
    let timestampToCheck;
    if (forLocalInvoke === true) {
        if (fs_extra_1.default.existsSync(executablePath)) {
            timestampToCheck = new Date(fs_extra_1.default.statSync(executablePath).mtime);
        }
    }
    else {
        timestampToCheck = request.lastBuildTimestamp;
    }
    if (force === true || !timestampToCheck || isBuildStale(request.srcRoot, timestampToCheck, outDir)) {
        const srcDir = path_1.default.join(request.srcRoot, constants_1.SRC);
        if (fs_extra_1.default.existsSync(outDir)) {
            fs_extra_1.default.emptyDirSync(outDir);
        }
        else {
            fs_extra_1.default.mkdirSync(outDir);
        }
        const envVars = {};
        if (forLocalInvoke === false) {
            envVars.GOOS = 'linux';
            envVars.GOARCH = 'amd64';
        }
        if (isWindows) {
            envVars.CGO_ENABLED = 0;
        }
        exports.executeCommand(['build', '-o', executablePath, '.'], true, envVars, srcDir);
        rebuilt = true;
    }
    return {
        rebuilt,
    };
};
exports.checkDependencies = async (_runtimeValue) => {
    executablePath = which.sync(executableName, {
        nothrow: true,
    });
    if (executablePath === null) {
        return {
            hasRequiredDependencies: false,
            errorMessage: `${executableName} executable was not found in PATH, make sure it's available. It can be installed from https://golang.org/doc/install`,
        };
    }
    const versionOutput = exports.executeCommand(['version'], false);
    if (versionOutput) {
        const parts = versionOutput.split(' ');
        if (parts.length !== 4 || !parts[2].startsWith('go') || semver_1.coerce(parts[2].slice(2)) === null) {
            return {
                hasRequiredDependencies: false,
                errorMessage: `Invalid version string: ${versionOutput}`,
            };
        }
        const version = semver_1.coerce(parts[2].slice(2));
        if (semver_1.lt(version, minimumVersion) || semver_1.gte(version, maximumVersion)) {
            return {
                hasRequiredDependencies: false,
                errorMessage: `${executableName} version found was: ${version.format()}, but must be between ${minimumVersion.format()} and ${maximumVersion.format()}`,
            };
        }
    }
    return {
        hasRequiredDependencies: true,
    };
};
exports.buildResource = async (request, context) => exports.buildResourceInternal(request, context, false, false);
exports.packageResource = async (request, context) => {
    if (!request.lastPackageTimestamp || request.lastBuildTimestamp > request.lastPackageTimestamp) {
        const packageHash = await context.amplify.hashDir(request.srcRoot, [constants_1.DIST]);
        const zipFn = process.platform.startsWith('win') ? winZip : nixZip;
        await zipFn(request.srcRoot, request.dstFilename, context.print);
        return { packageHash };
    }
    return {};
};
const winZip = async (src, dest, print) => {
    await execa_1.default(executableName, ['get', '-u', 'github.com/aws/aws-lambda-go/cmd/build-lambda-zip']);
    const goPath = process.env.GOPATH;
    if (!goPath) {
        throw new Error('Could not determine GOPATH. Make sure it is set.');
    }
    await execa_1.default(path_1.default.join(goPath, 'bin', 'build-lambda-zip.exe'), ['-o', dest, path_1.default.join(src, constants_1.BIN, constants_1.MAIN_BINARY)]);
    const resourceName = src.split(path_1.default.sep).pop();
    print.warning(`If the function ${resourceName} depends on assets outside of the go binary, you'll need to manually zip the binary along with the assets using WSL or another shell that generates a *nix-like zip file.`);
    print.warning('See https://github.com/aws/aws-lambda-go/issues/13#issuecomment-358729411.');
};
const nixZip = async (src, dest) => {
    const outDir = path_1.default.join(src, constants_1.BIN);
    const mainFile = path_1.default.join(outDir, constants_1.MAIN_BINARY);
    const file = fs_extra_1.default.createWriteStream(dest);
    return new Promise(async (resolve, reject) => {
        file.on('close', () => {
            resolve();
        });
        file.on('error', err => {
            reject(new Error(`Failed to zip with error: [${err}]`));
        });
        const zip = archiver_1.default.create('zip', {});
        zip.pipe(file);
        zip.file(mainFile, {
            name: constants_1.MAIN_BINARY,
            mode: 755,
        });
        zip.glob('**/*', {
            cwd: outDir,
            ignore: [mainFile],
        });
        zip.finalize();
    });
};
//# sourceMappingURL=runtime.js.map